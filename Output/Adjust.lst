C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADJUST
OBJECT MODULE PLACED IN .\Output\Adjust.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil\C51\BIN\C51.EXE Core\code\Adjust.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG
                    - OBJECTEXTEND PRINT(.\Output\Adjust.lst) OBJECT(.\Output\Adjust.obj)

line level    source

   1          /*===========================================================
   2           * Copyright (c)      Realtek Semiconductor Corporation, 2005
   3           * All rights reserved.
   4           * ========================================================== */
   5          
   6          /*==================== File Description ===================== */
   7          /**
   8           * @file
   9           *      This file is osd control declaration related functions.
  10           *
  11           * @author      $Author: hillwang $
  12           * @date        $Date: 2006-09-07 19:38:12 +0800 (?Ÿæ??? 07 ä¹æ? 2006) $
  13           * @version     $Revision: 1187 $
  14           * @ingroup Auto
  15           */
  16          
  17          /**
  18           * @addtogroup Auto
  19           * @{
  20           */
  21          
  22          #define _ADJUST_C
  23          /*===================== Module dependency  ================== */
  24          #include "Core\Header\Include.h"
  25          
  26          /*======================= Private Types ===================== */
  27          
  28          /*======================== Definitions ====================== */
  29          
  30          /*========================== Variables ====================== */
  31          //BYTE idata ucAdjustCtrl = 0;
  32          
  33          /*=================== Local Functions Phototype ==============*/
  34          static void CAdjustSetSharpnessTable(bit scaling,BYTE code *pArray0, BYTE code *pArray1);
  35          void CAdjustPeakingCoring(void);
  36          void CAdjustPeakingFilter(SBYTE ucPeaking);
  37          
  38          /*=========================== Functions ===================== */
  39          //--------------------------------------------------
  40          // Description  : Adjust IHS delay
  41          // Input Value  : IHS delay
  42          // Output Value : None
  43          //--------------------------------------------------
  44          void CAdjustIHSDelay(WORD usIHSDelay)
  45          {
  46   1          CScalerSetBit(_VGIP_HV_DELAY_1E, ~_BIT0, HIBYTE(usIHSDelay) & _BIT0);
  47   1          CScalerSetByte(_IHS_DELAY_1D, LOBYTE(usIHSDelay));
  48   1      }
  49          
  50          //--------------------------------------------------
  51          // Description  : Adjust IVS delay
  52          // Input Value  : IVS delay
  53          // Output Value : None
  54          //--------------------------------------------------
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 2   

  55          void CAdjustIVSDelay(WORD usIVSDelay)
  56          {
  57   1          CScalerSetBit(_VGIP_HV_DELAY_1E, ~_BIT1, (usIVSDelay >> 7) & _BIT1);
  58   1          CScalerSetByte(_IVS_DELAY_1C, LOBYTE(usIVSDelay));
  59   1      }
  60          
  61          //--------------------------------------------------
  62          // Description  : Adjust Dclk offset
  63          // Input Value  : Dclk offset
  64          // Output Value : None
  65          //--------------------------------------------------
  66          void CAdjustDclkOffset(WORD usDclkOffset)
  67          {                      
  68   1              CScalerPageSelect(_PAGE1);
  69   1          CScalerSetBit(_P1_DCLK_FINE_TUNE_OFFSET_MSB_C4, 0xf0, HIBYTE(usDclkOffset) & 0x0f);
  70   1          CScalerSetByte(_P1_DCLK_FINE_TUNE_OFFSET_LSB_C5, LOBYTE(usDclkOffset));
  71   1          CScalerSetBit(_P1_DCLK_SPREAD_SPECTRUM_C6, ~_BIT2, _BIT2);
  72   1      }
  73          
  74          //--------------------------------------------------
  75          // Description  : Adjust spread spectrum range
  76          // Input Value  : Spread spectrum range
  77          // Output Value : None
  78          //--------------------------------------------------
  79          void CAdjustSpreadSpectrumRange(BYTE ucSpreadRange)
  80          {
  81   1          CScalerPageSelect(_PAGE1);
  82   1          CScalerSetBit(_P1_DCLK_SPREAD_SPECTRUM_C6, 0x0f, (ucSpreadRange << 4) & 0xf0);
  83   1          CScalerSetBit(_P1_DCLK_SPREAD_SPECTRUM_C6, ~_BIT2, _BIT2);
  84   1      }
  85          
  86          //--------------------------------------------------
  87          // Description  : Sync processor measure start
  88          // Input Value  : None
  89          // Output Value : None
  90          //--------------------------------------------------
  91          void CAdjustSyncProcessorMeasureStart(void)
  92          {
  93   1          CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT5, _BIT5);
  94   1      }
  95          
  96          //--------------------------------------------------
  97          // Description  : Turn on the error correction function
  98          // Input Value  : None
  99          // Output Value : None
 100          //--------------------------------------------------
 101          void CAdjustTMDSErrorCorrectionOn(void)
 102          {
 103   1          CScalerPageSelect(_PAGE2);
 104   1          CScalerSetBit(_P2_UP_DOWN_CTRL2_B7, ~(_BIT7 | _BIT6 | _BIT5), _BIT7);
 105   1      }
 106          
 107          #if(((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)) && (_DVI_LONG_CABLE_SUPPORT == _ON))
              //--------------------------------------------------
              // Description  : Measure TMDS transition result
              // Input Value  : ucType    --> _TMDS_MEASURE_AVE, _TMDS_MEASURE_MAX, _TMDS_MEASURE_MIN
              //                ucSelect  --> _TMDS_MEASURE_HSYNC_BE, _TMDS_MEASURE_HSYNC_AF, _TMDS_MEASURE_DE_BE, _TMDS
             -_MEASURE_DE_AF
              // Output Value : Transition result
              //--------------------------------------------------
              BYTE CAdjustTMDSMeasure(BYTE ucType, BYTE ucSelect)
              {
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 3   

                      BYTE result;
              
                  CScalerPageSelect(_PAGE2);
                  CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~(_BIT6 | _BIT5), (ucType << 5));
                  CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~(_BIT7 | _BIT4 | _BIT3), (_BIT7 | (ucSelect << 3)));
              
                  if(CTimerPollingEventProc(60, CMiscTMDSMeasureEvent) == _FALSE)
                  {
                      CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~_BIT7, 0x00);
                      return 0xff;
                  }
              
                  CScalerRead(_P2_TMDS_MEAS_RESULT1_A3, 1, &result, _NON_AUTOINC);
              
                  return (result & 0x7f);
              }
              
              //--------------------------------------------------
              // Description  : TMDS CRC check process before displaying
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CAdjustTMDSCRCCheck(void)
              {
                  BYTE temp0, temp1;
                  DWORD dsod0, dsod1;
              
                  if(GET_FRAMESYNCSTATUS())
                  {
                      CTimerDelayXms(20);
              
                      temp0 = 0;
                      temp0 += CAdjustTMDSCRC(&pData[8]);
                      temp0 += CAdjustTMDSCRC(&pData[12]);
                      dsod0 = abs(((DWORD *)pData)[2] - ((DWORD *)pData)[3]);
              
                      if(temp0 < 2)
                      {
                              CScalerPageSelect(_PAGE2);
                              CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT5 | _BIT6), CScalerGetBit(_P2_ANALOG_COMMON_CTRL2
             -_AB, (_BIT6 | _BIT5)) ^ (_BIT5 | _BIT6));
              
                              temp1 = 0;
                                      temp1 += CAdjustTMDSCRC(&pData[8]);
                                      temp1 += CAdjustTMDSCRC(&pData[12]);
                                      dsod1 = abs(((DWORD *)pData)[2] - ((DWORD *)pData)[3]);
              
                                      if(temp1 < 2)
                                      {
                                              if(GET_USE_TRANSITION_RESULT())
                                              {
                                                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT5 | _BIT6), CScalerGetBit(_P2_ANALOG_COMMON_CTRL2_AB,
             - (_BIT6 | _BIT5)) ^ (_BIT5 | _BIT6));
                                              }
                                      else
                                              {
                                                      if(dsod0 <= dsod1)
                                                              CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT5 | _BIT6), CScalerGetBit(_P2_ANALOG_COMMON_CTRL2_AB
             -, (_BIT6 | _BIT5)) ^ (_BIT5 | _BIT6));
                                              }
                                      }
                                      else
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 4   

                                      {
                                              //CModeSetDigitalCapture();
                                      }
                              }
                              else
                              {
                                      //CModeSetDigitalCapture();
                              }
                      }
              }
              
              //--------------------------------------------------
              // Description  : Get TMDS transition difference
              // Input Value  : ucPar     --> _MEASURE_HSYNC or _MEASURE_DE
              // Output Value : Transition difference result
              //--------------------------------------------------
              BYTE CAdjustTMDSEqualizerCheck(BYTE ucPar)
              {
                  BYTE result0, result1;
              
                  if(ucPar == _MEASURE_HSYNC)
                  {
                      result0 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_HSYNC_BE);
                      if(result0 == 0xff)     return 0xff;
                      else if(result0 < 6)    return 0xfe;
              
                      result1 = CAdjustTMDSMeasure(_TMDS_MEASURE_MIN, _TMDS_MEASURE_HSYNC_AF);
                      if(result1 == 0xff)     return 0xff;
                      else if(result1 < 6)    return 0xfe;
                  }
                  else if(ucPar == _MEASURE_DE)
                  {
                      result0 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_DE_BE);
                      if(result0 == 0xff)     return 0xff;
                      else if(result0 < 6)    return 0xfe;
              
                      result1 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_DE_AF);
                      if(result1 == 0xff)     return 0xff;
                      else if(result1 < 6)    return 0xfe;
                  }
              
                  result0 = abs(result0 - result1);
              
                  if(result0 <= 2)
                      result0 = 0;
              
                  return result0;
              }
              
              //--------------------------------------------------
              // Description  : Adjust TMDS equalizer setting
              // Input Value  : None
              // Output Value : return _TRUE if success
              //--------------------------------------------------
              bit CAdjustTMDSEqualizer(void)
              {
                  BYTE cnt, result0, result1;
              
                  CLR_USE_TRANSITION_RESULT();
                  CScalerPageSelect(_PAGE2);
                  CScalerSetByte(_P2_TMDS_MEAS_SELECT_A1, 0x21);
                  CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~(_BIT6 | _BIT5), _BIT5);
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 5   

              
                  cnt = 1;
                  do
                  {
                      CScalerSetBit(_P2_TMDS_MEAS_SELECT_A1, 0xf0, (cnt%16));
              
                      result0 = CAdjustTMDSMeasure(_TMDS_MEASURE_MAX, _TMDS_MEASURE_DE_BE);
                      if(result0 == 0xff)
                          return _FALSE;
              
                      if(result0 > 80)
                          break;
              
                      cnt++;
                  }
                  while(cnt <= 16);
              
                  cnt = 0;
              
                  CScalerPageSelect(_PAGE2);
                  CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), 0x00);
                  result0 = CAdjustTMDSEqualizerCheck(_MEASURE_HSYNC);
                  if(result0 == 0xff)     return _FALSE;
                  if(result0 == 0xfe)     cnt += 1;
              
                  CScalerPageSelect(_PAGE2);
                  CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), _BIT4);
                  result1 = CAdjustTMDSEqualizerCheck(_MEASURE_HSYNC);
                  if(result1 == 0xff)     return _FALSE;
                  if(result1 == 0xfe)     cnt += 2;
              
                  if((abs(result0 - result1) <= 2) || (cnt != 0))
                  {
                      cnt = 0;
              
                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), 0x00);
                      result0 = CAdjustTMDSEqualizerCheck(_MEASURE_DE);
                      if(result0 == 0xff)     return _FALSE;
                      if(result0 == 0xfe)     cnt += 1;
              
                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), _BIT4);
                      result1 = CAdjustTMDSEqualizerCheck(_MEASURE_DE);
                      if(result1 == 0xff)     return _FALSE;
                      if(result1 == 0xfe)     cnt += 2;
                  }
              
                  if((result0 <= result1) || (cnt >= 2))
                      CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT6 | _BIT5 | _BIT4), (_BIT6 | _BIT5 | _BIT4));
              
                  if(abs(result0 - result1) > 2)
                      SET_USE_TRANSITION_RESULT();
              
                  return _TRUE;
              }
              #endif  // End of #if(((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)) && (_DVI_LONG_CABLE_SUPPORT == _O
             -N))
 292          
 293          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))
 294          //--------------------------------------------------
 295          // Description  : Set digital mode capture
 296          // Input Value  : None
 297          // Output Value : None
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 6   

 298          //--------------------------------------------------
 299          void CAdjustSetDigitalCapture(void)
 300          {
 301   1          CScalerSetBit(_VGIP_CTRL_10, ~_BIT1, _BIT1);
 302   1          CScalerSetBit(_IPH_ACT_STA_H_14, 0xf8, 0x00);
 303   1          CScalerSetByte(_IPH_ACT_STA_L_15, 0x00);
 304   1          CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT2 | _BIT1 | _BIT0), _BIT2 | _BIT1 | _BIT0);
 305   1          CScalerSetByte(_IPV_ACT_STA_L_19, 0x00);
 306   1      }
 307          
 308          //--------------------------------------------------
 309          // Description  : Measure TMDS CRC value
 310          // Input Value  : None
 311          // Output Value : CRC value, DWORD data type
 312          //--------------------------------------------------
 313          
 314          //--------------------------------------------------
 315          // Description  : TMDS digital/analog capture check process before displaying
 316          // Input Value  : None
 317          // Output Value : None
 318          //--------------------------------------------------
 319          void CAdjustTMDSCaptureCheck(void)
 320          {
 321   1          BYTE flag = 0;
 322   1      
 323   1          if(flag)
 324   1          {
 325   2              CAdjustSetDigitalCapture();
 326   2              CTimerDelayXms(20);
 327   2          }
 328   1      
 329   1      }
 330          #endif  // End of #if(_TMDS_SUPPORT == _ON)
 331          
 332          #if(_HDCP_SUPPORT == _ON)
 333          //--------------------------------------------------
 334          // Description  : Adjust HDCP key
 335          // Input Value  : None
 336          // Output Value : None
 337          //--------------------------------------------------
 338          void CAdjustHDCP(void)
 339          {
 340   1          CScalerPageSelect(_PAGE2);
 341   1          CScalerSetByte(_P2_HDCP_CTRL_C0, 0x06);
 342   1          CScalerWrite(_P2_DEVICE_KEY_ACCESS_PORT_C1, 320, tHDCP_KEY_TABLE_0, _NON_AUTOINC);
 343   1          CScalerCodeW(tHDCP_CTRL);
 344   1          CScalerSetByte(_P2_HDCP_CTRL_C0, 0x01);
 345   1      }
 346          #endif
 347          
 348          //--------------------------------------------------
 349          // Description  : Enable watch dog
 350          // Input Value  : ucPar --> Parameter for watch dog
 351          // Output Value : None
 352          //--------------------------------------------------
 353          void CAdjustEnableWatchDog(BYTE ucPar)
 354          {
 355   1              // add this line by Moya, we don't enable watch-dog at all.
 356   1              //return;
 357   1          if (bCNoCheckSyncMode())
 358   1              return;
 359   1      
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 7   

 360   1          if(GET_FRAMESYNCSTATUS())
 361   1          {
 362   2              CScalerSetByte(_WATCH_DOG_CTRL0_0C, 0x00);
 363   2              CMiscClearStatusRegister();
 364   2              CScalerSetBit(_WATCH_DOG_CTRL0_0C, ~ucPar, 0x06 | ucPar);  //Ming-Yen
 365   2                      ucPar = ucPar + 0; //Ming-Yen
 366   2          }
 367   1      }
 368          
 369          //--------------------------------------------------
 370          // Description  : Disable watch dog
 371          // Input Value  : ucPar --> Parameter for watch dog
 372          // Output Value : None
 373          //--------------------------------------------------
 374          void CAdjustDisableWatchDog(BYTE ucPar)
 375          {
 376   1          BYTE temp;
 377   1      
 378   1          CScalerSetBit(_WATCH_DOG_CTRL0_0C, ~ucPar, 0x00);
 379   1              temp = CScalerGetBit(_WATCH_DOG_CTRL0_0C, (_BIT7 | _BIT6 | _BIT5 | _BIT4 | _BIT3));
 380   1          if(temp == 0x00)
 381   1              CScalerSetByte(_WATCH_DOG_CTRL0_0C, 0x00);
 382   1      }
 383          
 384          //--------------------------------------------------
 385          // Description  : Adjust gamma
 386          // Input Value  : Gamma table type and gamma tables
 387          // Output Value : None
 388          //--------------------------------------------------
 389          void CAdjustGamma(BYTE ucGammaTableType, BYTE *pGammaTableArrayR, BYTE *pGammaTableArrayG, BYTE *pGammaTab
             -leArrayB)
 390          {
 391   1          WORD cnt;
 392   1          BYTE i, temp;
 393   1      
 394   1          if((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) || (ucGammaTableType == _FULL_GAMMA_NORMAL_TABLE)
             -)
 395   1          {
 396   2              CScalerSetByte(_GAMMA_CTRL_67, 0x80 | ucGammaTableType);
 397   2              CScalerWrite(_GAMMA_PORT_66, ((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) ? 256 : 384), pGam
             -maTableArrayR, _NON_AUTOINC);
 398   2              CScalerSetByte(_GAMMA_CTRL_67, 0x90 | ucGammaTableType);
 399   2              CScalerWrite(_GAMMA_PORT_66, ((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) ? 256 : 384), pGam
             -maTableArrayG, _NON_AUTOINC);
 400   2              CScalerSetByte(_GAMMA_CTRL_67, 0xa0 | ucGammaTableType);
 401   2              CScalerWrite(_GAMMA_PORT_66, ((ucGammaTableType == _COMPACT_GAMMA_NORMAL_TABLE) ? 256 : 384), pGam
             -maTableArrayB, _NON_AUTOINC);
 402   2              CScalerSetByte(_GAMMA_CTRL_67, 0x40);
 403   2          }
 404   1      #if(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)
                  else if(ucGammaTableType == _FULL_GAMMA_COMPRESS_TABLE2)
                  {
                       CScalerSetByte(_GAMMA_CTRL_67, 0x81);
                      CRtdWriteGamma(pGammaTableArrayR);
                      CScalerSetByte(_GAMMA_CTRL_67, 0x91);
                      CRtdWriteGamma(pGammaTableArrayG);
                      CScalerSetByte(_GAMMA_CTRL_67, 0xa1);
                      CRtdWriteGamma(pGammaTableArrayB);
                      CScalerSetByte(_GAMMA_CTRL_67, 0x40);   
                  }
              #endif  
 416   1          else if((ucGammaTableType == _COMPACT_GAMMA_COMPRESS_TABLE) || (ucGammaTableType == _FULL_GAMMA_COMPRE
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 8   

             -SS_TABLE))
 417   1          {
 418   2              for(i=0;i<3;i++)
 419   2              {
 420   3                  ucVLDCnt    = 0;
 421   3                  ucVLDTemp   = 0;
 422   3      
 423   3                  if(i == 0)
 424   3                  {
 425   4                      CScalerSetByte(_GAMMA_CTRL_67, 0x80 | (ucGammaTableType % 2));
 426   4                      pvldarray   = (pGammaTableArrayR + 16);
 427   4                  }
 428   3                  else if(i == 1)
 429   3                  {
 430   4                      CScalerSetByte(_GAMMA_CTRL_67, 0x90 | (ucGammaTableType % 2));
 431   4                      pvldarray   = (pGammaTableArrayG + 16);
 432   4                  }
 433   3                  else
 434   3                  {
 435   4                      CScalerSetByte(_GAMMA_CTRL_67, 0xa0 | (ucGammaTableType % 2));
 436   4                      pvldarray   = (pGammaTableArrayB + 16);
 437   4                  }
 438   3      
 439   3                  for(temp=0;temp<16;temp++)
 440   3                      pData[temp] = *(pvldarray + temp - 16);
 441   3      
 442   3                  for(cnt=0;cnt<((ucGammaTableType == _COMPACT_GAMMA_COMPRESS_TABLE) ? 256 : 384);cnt++)
 443   3                  {
 444   4                      temp    = CScalerGetVLD() << 4;
 445   4                      temp    |= CScalerGetVLD();
 446   4                      CScalerSetByte(_GAMMA_PORT_66, temp);
 447   4                  }
 448   3              }
 449   2                      CScalerSetByte(_GAMMA_CTRL_67, 0x40);
 450   2              }
 451   1      }
 452          
 453          
 454          #if(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)
              void CRtdWriteGamma(UINT8  *array)
              {
                      int i,k=0,m=0;
                      int tmp;
                      int diff0;
                      int d2;
                      int k0;
               
                      int outA;
              
                      k0=outA=*array++; // //2x+0
                      diff0=*(array++);
              
                      for (i=0;i<256;i+=2)
                      {
                      tmp=*(array++);
                              //---even----------------------
                              d2=(tmp>>4)-8;
                              if (d2==-8)
                              d2=(char)*(array++);
               // dump k0
                              CScalerSetByte(_GAMMA_PORT_66,(k0>>2));
                              outA=outA+diff0; // 2x+1
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 9   

               // dump d0,
                              CScalerSetByte(_GAMMA_PORT_66,(((k0&3)<<6)|diff0));
                              diff0=diff0+d2; // d[2x+1]
              // dump d1
                              if (i==254) 
                                      diff0=0; // Last item :: without d2;
                              CScalerSetByte(_GAMMA_PORT_66,(diff0));
                              m++; 
                              k++;
                              //---odd-----------------------
                              d2=(tmp&0xf)-8;
                              if(d2 == -8)
                                      d2 = (char)*array++;
                              k0 = outA = outA + diff0;
                              diff0 = diff0 + d2; // d[2x+1];
                              m++; 
                              k++;
                      }
              }
              #endif
 498          
 499          
 500          //--------------------------------------------------
 501          // Description  : Set dithering
 502          // Input Value  : Dithering tables
 503          // Output Value : None
 504          //--------------------------------------------------
 505          void CAdjustDither(BYTE *pDitherSeqTable, BYTE * pDitherTable)
 506          {
 507   1          CScalerSetBit(_DITHERING_CTRL_6A, ~(_BIT7 | _BIT6), _BIT6);
 508   1          CScalerWrite(_DITHERING_DATA_ACCESS_69, 24, pDitherSeqTable, _NON_AUTOINC);
 509   1          CScalerSetBit(_DITHERING_CTRL_6A, ~(_BIT7 | _BIT6), _BIT7);
 510   1          CScalerWrite(_DITHERING_DATA_ACCESS_69, 24, pDitherTable, _NON_AUTOINC);
 511   1          CScalerSetByte(_DITHERING_CTRL_6A, 0x38);
 512   1      }
 513          //--------------------------------------------------
 514          // Description  : Adjust sharpness for scale up
 515          // Input Value  : None
 516          // Output Value : None
 517          //--------------------------------------------------
 518          void CAdjustSharpnessForScaleUp(void)
 519          {
 520   1              CAdjustSetSharpnessTable(_SCALE_UP,tSU_COEF_TABLE[GET_SHARPNESS()], tSU_COEF_TABLE[GET_SHARPNESS()]);
 521   1      }
 522          //--------------------------------------------------
 523          // Description  : Adjust sharpness for scale down
 524          // Input Value  : None
 525          // Output Value : None
 526          //--------------------------------------------------
 527          void CAdjustSharpnessForScaleDown(void)
 528          {
 529   1          CAdjustSetSharpnessTable(_SCALE_DOWN, tSCALE_DOWN_COEF_TABLE[GET_SHARPNESS()], tSCALE_DOWN_COEF_TABLE[
             -GET_SHARPNESS()]);
 530   1      }
 531          
 532          
 533          //--------------------------------------------------
 534          // Description  : Set Sharpness Table
 535          // Input Value  : 1: Scale-Up
 536          //                0: Scale-Down  
 537          // Output Value : None
 538          //--------------------------------------------------
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 10  

 539          void CAdjustSetSharpnessTable(bit scaling, BYTE code *pArray0, BYTE  code *pArray1)
 540          {
 541   1          if(scaling)
 542   1          {
 543   2              CScalerSetByte(_FILTER_CTRL_35, 0xb0);
 544   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray0, _NON_AUTOINC);
 545   2              CScalerSetByte(_FILTER_CTRL_35, 0xc0);
 546   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray1, _NON_AUTOINC);
 547   2              CScalerSetByte(_FILTER_CTRL_35, 0x00);
 548   2      
 549   2              CScalerSetByte(_FILTER_CTRL_35, 0x0b);
 550   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray0, _NON_AUTOINC);
 551   2              CScalerSetByte(_FILTER_CTRL_35, 0x0c);
 552   2              CScalerWrite(_FILTER_ACCESS_PORT_36, 128, pArray1, _NON_AUTOINC);
 553   2              CScalerSetByte(_FILTER_CTRL_35, 0x00);
 554   2          }
 555   1          else
 556   1          {
 557   2              CScalerPageSelect(_PAGE6);
 558   2              CScalerSetByte(_P6_UZD_FIR_COEF_INDEX_F3, 0x00);
 559   2              CScalerWrite(_P6_UZD_FIR_COEF_PORT_F4, 64, pArray0, _NON_AUTOINC);
 560   2              CScalerSetByte(_P6_UZD_FIR_COEF_INDEX_F3, 0x80);
 561   2              CScalerWrite(_P6_UZD_FIR_COEF_PORT_F4, 64, pArray1, _NON_AUTOINC);
 562   2              CScalerSetByte(_P6_UZD_FIR_COEF_INDEX_F3, 0x00);
 563   2          }
 564   1      }
 565          
 566          //--------------------------------------------------
 567          // Description  : Adjust color precessing brightness
 568          // Input Value  : None
 569          // Output Value : None
 570          //--------------------------------------------------
 571          void CAdjustSetBrightness(void)
 572          {
 573   1          CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
 574   1          CScalerWrite(_CB_DATA_PORT_65, 3, pData, _NON_AUTOINC);
 575   1          CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
 576   1      }
 577          
 578          //--------------------------------------------------
 579          // Description  : Adjust color processing contrast
 580          // Input Value  : None
 581          // Output Value : None
 582          //--------------------------------------------------
 583          void CAdjustSetContrast(void)
 584          {
 585   1      //    CScalerSetByte(_CB_ACCESS_PORT_64, 0x83);
 586   1      //    CScalerWrite(_CB_DATA_PORT_65, 3, pData, _NON_AUTOINC);
 587   1      //    CScalerSetByte(_CB_ACCESS_PORT_64, 0x00); 
 588   1      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 589   1              CScalerSetByte(_CB_ACCESS_PORT_64, 0x83);
 590   1              CScalerSetByte(_CB_DATA_PORT_65, 0x8e);//hong 
 591   1      
 592   1                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x84);
 593   1              CScalerSetByte(_CB_DATA_PORT_65, 0x85);//greed            Contrast
 594   1      
 595   1                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x85);
 596   1              CScalerSetByte(_CB_DATA_PORT_65, 0x85);//blu
 597   1      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 598   1      /*              CScalerSetByte(_CB_ACCESS_PORT_64, 0x86);
 599   1              CScalerSetByte(_CB_DATA_PORT_65, 0);//hong 
 600   1      
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 11  

 601   1                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x87);
 602   1              CScalerSetByte(_CB_DATA_PORT_65, 0);//greed           bright
 603   1      
 604   1                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x88);
 605   1              CScalerSetByte(_CB_DATA_PORT_65, 0);//blu
 606   1      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 607   1                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x89);
 608   1              CScalerSetByte(_CB_DATA_PORT_65, 0x80);//hong 
 609   1      
 610   1                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x8a);
 611   1              CScalerSetByte(_CB_DATA_PORT_65, 0x80);//greed             Contrast
 612   1      
 613   1                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x8b);
 614   1              CScalerSetByte(_CB_DATA_PORT_65, 0x80);//blu*/
 615   1      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 616   1              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
 617   1      
 618   1      }
 619          
 620          //--------------------------------------------------
 621          // Description  : Adjust ADC gain
 622          // Input Value  : None
 623          // Output Value : None
 624          //--------------------------------------------------
 625          void CAdjustAdcGain(void)
 626          {
 627   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
 628   1              {
 629   2      #if(_ADC0_INPUT_SWAP_RG == _ON)
                      pData[1] = stAdcData.AdcGain[_RED];
                      pData[0] = stAdcData.AdcGain[_GREEN];
                      pData[2] = stAdcData.AdcGain[_BLUE];
              
              #elif(_ADC0_INPUT_SWAP_RB == _ON)
                      pData[2] = stAdcData.AdcGain[_RED];
                              pData[1] = stAdcData.AdcGain[_GREEN];
                              pData[0] = stAdcData.AdcGain[_BLUE];
              
              #elif(_ADC0_INPUT_SWAP_GB == _ON)
                      pData[0] = stAdcData.AdcGain[_RED];
                      pData[2] = stAdcData.AdcGain[_GREEN];
                      pData[1] = stAdcData.AdcGain[_BLUE];
              #else
 644   2              pData[0] = stAdcData.AdcGain[_RED];
 645   2              pData[1] = stAdcData.AdcGain[_GREEN];
 646   2              pData[2] = stAdcData.AdcGain[_BLUE];
 647   2      #endif//(_ADC_INPUT_SWAP_RG == _ON)
 648   2              }
 649   1              else// if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
 650   1              {
 651   2      #if(_ADC1_INPUT_SWAP_RG == _ON)
                      pData[1] = stYPbPrData.YPbPrGain[_RED];
                      pData[0] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = stYPbPrData.YPbPrGain[_BLUE];
              #elif(_ADC1_INPUT_SWAP_RB == _ON)
                      pData[2] = stYPbPrData.YPbPrGain[_RED];
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[0] = stYPbPrData.YPbPrGain[_BLUE];
              #elif(_ADC1_INPUT_SWAP_GB == _ON)
 660   2              pData[0] = stYPbPrData.YPbPrGain[_RED];
 661   2              pData[2] = stYPbPrData.YPbPrGain[_GREEN];
 662   2              pData[1] = stYPbPrData.YPbPrGain[_BLUE];
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 12  

 663   2      #else
                      pData[0] = stYPbPrData.YPbPrGain[_RED];
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = stYPbPrData.YPbPrGain[_BLUE];
              #endif
 668   2              }
 669   1              {
 670   2                      CScalerPageSelect(_PAGE0);              
 671   2              CScalerWrite(_P0_RED_GAIN_C0, 3, pData, _AUTOINC);
 672   2      
 673   2              }
 674   1      }
 675          
 676          //--------------------------------------------------
 677          // Description  : Adjust ADC offset
 678          // Input Value  : None
 679          // Output Value : None
 680          //--------------------------------------------------
 681          void CAdjustAdcOffset(void)
 682          {
 683   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
 684   1              {
 685   2      #if(_ADC0_INPUT_SWAP_RG == _ON)
                      pData[4] = stAdcData.AdcOffset[_RED];
                      pData[3] = stAdcData.AdcOffset[_GREEN];
                      pData[5] = stAdcData.AdcOffset[_BLUE];
              #elif(_ADC0_INPUT_SWAP_RB == _ON)
                      pData[5] = stAdcData.AdcOffset[_RED];
                      pData[4] = stAdcData.AdcOffset[_GREEN];
                      pData[3] = stAdcData.AdcOffset[_BLUE];
              #elif(_ADC0_INPUT_SWAP_GB == _ON)
                      pData[3] = stAdcData.AdcOffset[_RED];
                      pData[5] = stAdcData.AdcOffset[_GREEN];
                      pData[4] = stAdcData.AdcOffset[_BLUE];
              #else
 698   2              pData[3] = stAdcData.AdcOffset[_RED];
 699   2              pData[4] = stAdcData.AdcOffset[_GREEN];
 700   2              pData[5] = stAdcData.AdcOffset[_BLUE];
 701   2      #endif
 702   2              }
 703   1              else 
 704   1          {
 705   2      #if(_ADC1_INPUT_SWAP_RG == _ON)
                      pData[4] = stYPbPrData.YPbPrOffset[_RED];
                      pData[3] = stYPbPrData.YPbPrOffset[_GREEN];
                      pData[5] = stYPbPrData.YPbPrOffset[_BLUE];
              #elif(_ADC1_INPUT_SWAP_RB == _ON)
                      pData[5] = stYPbPrData.YPbPrOffset[_RED];
                      pData[4] = stYPbPrData.YPbPrOffset[_GREEN];
                      pData[3] = stYPbPrData.YPbPrOffset[_BLUE];
              #elif(_ADC1_INPUT_SWAP_GB == _ON)
 714   2              pData[3] = stYPbPrData.YPbPrOffset[_RED];
 715   2                      pData[5] = stYPbPrData.YPbPrOffset[_GREEN];
 716   2              pData[4] = stYPbPrData.YPbPrOffset[_BLUE];
 717   2      #else
                      pData[3] = stYPbPrData.YPbPrOffset[_RED];
                      pData[4] = stYPbPrData.YPbPrOffset[_GREEN];
                      pData[5] = stYPbPrData.YPbPrOffset[_BLUE];
              #endif
 722   2              }
 723   1              {
 724   2              CScalerPageSelect(_PAGE0);
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 13  

 725   2                      //pData[3] = pData[4] = pData[5] = 0x80;        //provisional ¼È©w
 726   2                      CScalerWrite(_P0_RED_OFFSET_C3, 3, &pData[3], _AUTOINC);
 727   2              }
 728   1      }
 729          
 730          //--------------------------------------------------
 731          // Description  : Adjust ADC gain and offset
 732          // Input Value  : None
 733          // Output Value : None
 734          //--------------------------------------------------
 735          void CAdjustAdcGainOffset(void)
 736          {
 737   1          CAdjustAdcGain();
 738   1          CAdjustAdcOffset();
 739   1      }
 740          
 741          //--------------------------------------------------
 742          // Description  : Adjust background color
 743          // Input Value  : Red, green and blue color settings
 744          // Output Value : None
 745          //--------------------------------------------------
 746          void CAdjustBackgroundColor(BYTE ucRed, BYTE ucGreen, BYTE ucBlue)
 747          {
 748   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~_BIT5, 0x00);
 749   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~_BIT5, _BIT5);
 750   1      
 751   1          CScalerSetByte(_BGND_COLOR_CTRL_6D, ucRed);
 752   1          CScalerSetByte(_BGND_COLOR_CTRL_6D, ucGreen);
 753   1          CScalerSetByte(_BGND_COLOR_CTRL_6D, ucBlue);
 754   1      
 755   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~_BIT5, 0x00);
 756   1      }
 757          
 758          //--------------------------------------------------
 759          bit CheckInterLace(void)
 760          {
 761   1              CTimerDelayXms(200);
 762   1              CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
 763   1              
 764   1              if(pData[0] & 0x20)
 765   1                      return 1;
 766   1                      
 767   1              return 0;
 768   1      }
 769          
 770          //--------------------------------------------------
 771          void CAdjustInterlaceIVS2DVSDelay(void)
 772          {
 773   1          UINT16 usTemp;
 774   1              
 775   1      //    CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
 776   1      
 777   1              if(CTimerPollingEventProc(5, CheckInterLace))
 778   1          //if(pData[0] & 0x20)
 779   1          {
 780   2              CScalerSetBit(_SCALE_CTRL_32, ~(_BIT7 | _BIT6), _BIT7); 
 781   2              CScalerRead(_IPV_ACT_LEN_H_1A, 2, pData, _AUTOINC);
 782   2              usTemp = (((WORD) pData[0] & 0x07) << 8) | (WORD) pData[1];
 783   2              if(usTemp <= 288)       //480i 576i     
 784   2                      CScalerSetBit(_VGIP_SIGINV_11, ~_BIT4, 0);
 785   2              else
 786   2                      CScalerSetBit(_VGIP_SIGINV_11, ~_BIT4, _BIT4);          
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 14  

 787   2      
 788   2      
 789   2              CScalerRead(_IV_DV_DELAY_CLK_ODD_41, LENGTH(1), pData, _NON_AUTOINC);
 790   2              usTemp = (WORD)pData[0] * 16 + 16;
 791   2              usTemp += stModeInfo.IHTotal/2;
 792   2      
 793   2              CScalerSetByte(_IV_DV_DELAY_CLK_ODD_41, ((usTemp - 16) / 16));
 794   2                      usTemp -= stModeInfo.IHTotal / 2;
 795   2                      //usTemp += stModeInfo.IHTotal / 2;
 796   2      
 797   2                      CScalerSetByte(_IV_DV_DELAY_CLK_EVEN_42, ((usTemp - 16) / 16));
 798   2      
 799   2                      CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~_BIT1, _BIT1);
 800   2                      CScalerSetBit(_IPV_ACT_LEN_H_1A, 0xff, 0x20); //forster modified 061123 to fix the frame sync problem
 801   2      
 802   2          }
 803   1      }
 804          
 805          //--------------------------------------------------
 806          // Description  : Calculate the suitable IVS to DVS delay
 807          //                CR[38] : IVS to DVS delay in IHS lines
 808          //                CR[1E] : IVS to DVS delay in ICLK * 16
 809          // Input Value  : Scaling setting
 810          // Output Value : IV to DV delay lines
 811          //--------------------------------------------------
 812          BYTE CAdjustIVS2DVSDelay(BYTE ucOption)
 813          {
 814   1          ((DWORD *)pData)[0] = ((DWORD)stDisplayInfo.DHTotal * stDisplayInfo.DVStartPos) + Panel[ucPanelSelect]
             -->DHStartPos;
 815   1      //    ((DWORD *)pData)[0] = ((DWORD)stDisplayInfo.DHTotal * Panel[ucPanelSelect]->DVStartPos) + Panel[ucPa
             -nelSelect]->DHStartPos;
 816   1          ((DWORD *)pData)[0] = ((DWORD *)pData)[0] * stModeInfo.IVHeight / stDisplayInfo.DVHeight * stModeInfo.
             -IHTotal / stDisplayInfo.DHTotal;
 817   1          ((DWORD *)pData)[1] = ((DWORD)stModeInfo.IHTotal * (stModeInfo.IVStartPos - (ucVStartBias + _PROGRAM_V
             -DELAY))) + stModeInfo.IHStartPos - (ucHStartBias + _PROGRAM_HDELAY);
 818   1      
 819   1          if (_GET_INPUT_SOURCE() !=_SOURCE_DVI && _GET_INPUT_SOURCE() !=_SOURCE_HDMI)
 820   1          {
 821   2              ((DWORD *)pData)[0] = ((DWORD)stDisplayInfo.DHTotal * Panel[ucPanelSelect]->DVStartPos) + Panel[uc
             -PanelSelect]->DHStartPos;
 822   2              ((DWORD *)pData)[0] = ((DWORD *)pData)[0] * stModeInfo.IVHeight / stDisplayInfo.DVHeight * stModeI
             -nfo.IHTotal / stDisplayInfo.DHTotal;
 823   2              ((DWORD *)pData)[1] = ((DWORD)stModeInfo.IHTotal * (stModeInfo.IVStartPos - (ucVStartBias + _PROGR
             -AM_VDELAY))) + stModeInfo.IHStartPos - (ucHStartBias + _PROGRAM_HDELAY);
 824   2          }
 825   1      
 826   1          if(ucOption & _BIT0)
 827   1          {
 828   2              // V scale-up. Target 2.50 IHS delay
 829   2              // Reg[40] = 0 ==> Delay 1 line
 830   2              //((DWORD *)pData)[1] += (stModeInfo.IHTotal * 1) + 640;
 831   2              //eric 20070620
 832   2              CScalerPageSelect(_PAGE6);
 833   2              //if((CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1 | _BIT0)) && (~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _
             -BIT4))))
 834   2      #if(_DE_INTERLACE_SUPPORT == _ON)        
 835   2              if (bSourceVideo())
 836   2              {
 837   3                  if (stDisplayInfo.DHWidth < 700)
 838   3                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
 839   3                  else
 840   3                  {
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 15  

 841   4                      if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1)
             -)&&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)))
 842   4                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
 843   4                      else
 844   4                              ((DWORD *)pData)[1] += (stModeInfo.IHTotal *1) + 640;
 845   4                  }
 846   3              }
 847   2              else
 848   2              {
 849   3                      if(stModeInfo.IVHeight <= 288)
 850   3                      { 
 851   4                              if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1))&&
 852   4                         (CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)) && (Panel[ucPanelSelect]->DHWidth > 700)) // E
             -ricLee 0402 add for YPbPr
 853   4                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 3) + 640;
 854   4                              else
 855   4                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal *2) + 640;
 856   4                      }
 857   3                      else
 858   3                      { 
 859   4                              if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1))&&
 860   4                         (CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)) && (Panel[ucPanelSelect]->DHWidth > 700)) // E
             -ricLee 0402 add for YPbPr
 861   4                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
 862   4                              else
 863   4                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal *1) + 640;
 864   4                      }
 865   3                      }
 866   2      #else
                      if (bSourceVideo() && stDisplayInfo.DHWidth < 700)
                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
                      else
                      {
                              if((~(bit)(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT4))) &&(CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT1))&&(
             -CScalerGetBit(_P6_UZD_CTRL0_E3, _BIT0)))
                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal * 2) + 640;
                              else
                                      ((DWORD *)pData)[1] += (stModeInfo.IHTotal *1) + 640;
                      }
              #endif
 877   2      
 878   2          }
 879   1          else
 880   1          {
 881   2              if (ucOption & _BIT1)
 882   2              {
 883   3                  // V scale-down. Target 1.75 IHS delay
 884   3                  ((DWORD *)pData)[1]  += stModeInfo.IHTotal + ((DWORD)640 * stModeInfo.IVHeight / stDisplayInfo
             -.DVHeight);
 885   3              }
 886   2              else
 887   2              {
 888   3                  // V no scaling. Target 1.50 IHS delay
 889   3                  ((DWORD *)pData)[1]  += stModeInfo.IHTotal + 640;
 890   3              }
 891   2      
 892   2              // Turn on full-line buffer
 893   2              ((DWORD *)pData)[1]  += stModeInfo.IHTotal;
 894   2              CScalerSetBit(_SCALE_CTRL_32, ~_BIT4, _BIT4);
 895   2      
 896   2          }
 897   1      
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 16  

 898   1          if (((DWORD *)pData)[0] > ((DWORD *)pData)[1])
 899   1          {
 900   2              // You should never get into this code ....
 901   2          }
 902   1      
 903   1          ((DWORD *)pData)[0]  = ((DWORD *)pData)[1] - ((DWORD *)pData)[0];
 904   1      
 905   1          pData[14] = ((DWORD *)pData)[0] / stModeInfo.IHTotal;
 906   1          pData[15] = (((DWORD *)pData)[0] - ((DWORD)stModeInfo.IHTotal * pData[14])) / 16;
 907   1      
 908   1          CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~_BIT1, 0x00);
 909   1          CScalerSetByte(_IVS2DVS_DELAY_LINES_40, pData[14]);
 910   1          CScalerSetByte(_IV_DV_DELAY_CLK_ODD_41, pData[15]);
 911   1      
 912   1          return pData[14];
 913   1      }
 914          
 915          
 916          //--------------------------------------------------
 917          // Description  : Set display clock (Dclk) frequency in kHz
 918          // Input Value  : ulFreq    --> Target Dclk frequency
 919          // Output Value : None
 920          //--------------------------------------------------
 921          void CAdjustDPLL(DWORD ulFreq)
 922          {
 923   1      /*
 924   1          WORD mcode;
 925   1          BYTE div;
 926   1      
 927   1          // We want to set DPLL offset to middle(2048), so the target DPLL M/N setting should be 16/15 of targe
             -t frequency.
 928   1          mcode   = ulFreq * 8 * _DPLL_N_CODE * 16 / ((DWORD)_RTD_XTAL * 15);
 929   1      
 930   1          div     = 1;                                                // Output DPLL for DCLK
 931   1          mcode   = (mcode + 2) >> 2;                 // Round to integer
 932   1      
 933   1      
 934   1          // Original Formula : M_Code/Ich = 36.67 must be constant
 935   1          // Ich   = M_Code * 100 / 3667
 936   1          // Ich   = 1u + D0[0]*1u + D0[1]*2u + D0[2]*4u + D0[3]*8u (A)
 937   1      
 938   1          // Calculate the Ich,
 939   1          pData[5]    = ((WORD)mcode * 100 / 3667) - 1;
 940   1          pData[6]    = 0x00;
 941   1      
 942   1          if(pData[5] >= 8)
 943   1          {
 944   1              pData[5]    -= 8;
 945   1              pData[6]    |= 0x08;
 946   1          }
 947   1      
 948   1          if(pData[5] >= 4)
 949   1          {
 950   1              pData[5]    -= 4;
 951   1              pData[6]    |= 0x04;
 952   1          }
 953   1      
 954   1          if(pData[5] >= 2)
 955   1          {
 956   1              pData[5]    -= 2;
 957   1              pData[6]    |= 0x02;
 958   1          }
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 17  

 959   1      
 960   1          if(pData[5] >= 1)
 961   1          {
 962   1              pData[5]    -= 1;
 963   1              pData[6]    |= 0x01;
 964   1          }
 965   1      
 966   1          pData[0]    = mcode - 2;
 967   1      #if(_M2PLL_USE == _ON)
 968   1          pData[1]    = ((1 == div) ? 0x00 : 0x10) | ((_DPLL_N_CODE / _RTD_M2PLL_RATIO) - 2);
 969   1      #else
 970   1          pData[1]    = ((1 == div) ? 0x00 : 0x10) | (_DPLL_N_CODE - 2);
 971   1      #endif
 972   1          pData[2]    = 0x80 | pData[6];
 973   1          pData[3]    = 0x17;
 974   1      
 975   1          CScalerPageSelect(_PAGE1);
 976   1          CScalerWrite(_P1_DPLL_M_BF, 4, pData, _AUTOINC);
 977   1          CScalerSetBit(_P1_DPLL_OTHER_C3, ~_BIT1, _BIT1);
 978   1          if((bit)CScalerGetBit(_P1_DPLL_N_C0, _BIT7))
 979   1          {
 980   1              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, _BIT6);
 981   1              CTimerDelayXms(2);
 982   1              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, 0x00);
 983   1          }
 984   1      
 985   1      
 986   1          // Dclk frequency in Hz
 987   1          ((DWORD *)pData)[0] = (DWORD)_RTD_XTAL * 1000 / (div * 2) * mcode / _DPLL_N_CODE;
 988   1      
 989   1          // Offset resolution (Dclk / 2^15) in Hz
 990   1          ((DWORD *)pData)[1] = ((DWORD *)pData)[0] >> 15;
 991   1      
 992   1          // Target frequency of Dclk in Hz
 993   1          mcode       = (((DWORD *)pData)[0] - (ulFreq * 1000)) / ((DWORD *)pData)[1];
 994   1          mcode       = mcode & 0x0fff;
 995   1      
 996   1              //Enable DDS spread spectrum output function
 997   1              CScalerSetBit(_P1_EVEN_FIXED_LAST_LINE_CTRL_CA, ~_BIT0, _BIT0);
 998   1      
 999   1          CAdjustDclkOffset(mcode); */
1000   1          WORD mcode;
1001   1          BYTE div;
1002   1      
1003   1          // We want to set DPLL offset to middle(2048), so the target DPLL M/N setting should be 16/15 of targe
             -t frequency.
1004   1      #if(_TEST_DPLL)
              
                  mcode   = ulFreq * 8 * _DPLL_N_CODE * 16 / ((DWORD)_RTD_XTAL * 15);
              
                  if(mcode > 255)
                  {
                      div     = 1;                            // Output DPLL for DCLK
                      mcode   = (mcode + 2) >> 2;             // Round to integer
                  }
                  else
                  {
                      div     = 2;                            // Output DPLL/2 for DCLK
                      mcode   = (mcode + 1) >> 1;             // Round to integer
                  }
              
                  // Original Formula : M_Code/Ich = 17.6 must be constant
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 18  

                  // Ich   = M_Code * 10 / 176
                  // 2*Ich = M_Code * 20 / 176 , set D0[5] to 0, then I = 2 * Ich
                  // I     = 2 * Ich = 2.5u + D0[0]*2.5u + D0[1]*5u + D0[2]*10u + D0[3]*20u + D0[4]*30u (A)
                  // 2*I   = 4 * Ich = 5u + D0[0]*5u + D0[1]*10u + D0[2]*20u + D0[3]*40u + D0[4]*60u (A)
              
                  // Calculate the 4 * Ich,
                  pData[5]    = ((WORD)mcode * 4 * 10 / 176) - 5;
                  pData[6]    = 0x00;
                  
                  if(pData[5] >= 60)
                  {
                      pData[5]    -= 60;
                      pData[6]    |= 0x10;
                  }
              
                  if(pData[5] >= 40)
                  {
                      pData[5]    -= 40;
                      pData[6]    |= 0x08;
                  }
              
                  if(pData[5] >= 20)
                  {
                      pData[5]    -= 20;
                      pData[6]    |= 0x04;
                  }
              
                  if(pData[5] >= 10)
                  {
                      pData[5]    -= 10;
                      pData[6]    |= 0x02;
                  }
              
                  if(pData[5] >= 5)
                  {
                      pData[5]    -= 5;
                      pData[6]    |= 0x01;
                  }
              
                  pData[0]    = mcode - 2;
              #if(_M2PLL_USE == _ON)
                  pData[1]    = ((1 == div) ? 0x00 : 0x10) | ((_DPLL_N_CODE / _RTD_M2PLL_RATIO) - 2);
              #else
                  pData[1]    = ((1 == div) ? 0x00 : 0x10) | (_DPLL_N_CODE - 2);
              #endif
                  pData[2]    = 0x40 | pData[6]; 
                  pData[3]    = 0x0f;
              
              #else  //#if(_TEST_DPLL) 
1069   1       
1070   1          mcode   = ulFreq * 8 * _DPLL_N_CODE * 16 / ((DWORD)_RTD_XTAL * 15);
1071   1      
1072   1              //DebugPrintf("\n CAdjustDPLL =%x, ",(UINT8)(mcode>>8));
1073   1              //DebugPrintf("%x ",(UINT8)(mcode));
1074   1              if((GET_PNL_OUTPUT_BUS() == _PANEL_TTL) || (Panel[ucPanelSelect]->DHWidth < 1100))
1075   1          {    /*
1076   2                      if(mcode<38)
1077   2              {
1078   2                              div     = 8;                                                            // Output DPLL/2 for DCLK
1079   2                              mcode   = (mcode + 0) <<1;                      // Round to integer
1080   2                      }               
1081   2                      if(mcode<120)*/
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 19  

1082   2                      if(mcode<38)
1083   2              {
1084   3      //            div     = 4;                            // Output DPLL/2 for DCLK
1085   3        //          mcode   = (mcode + 1) >> 1;             // Round to integer
1086   3                  div     = 2;                            // Output DPLL/2 for DCLK
1087   3                  mcode   = (mcode + 1) >> 1;             // Round to integer
1088   3                      }               
1089   2                      else if(mcode<120)
1090   2              {
1091   3                              div     = 4;                                                            // Output DPLL/2 for DCLK
1092   3                              mcode   = (mcode + 0) >> 0;                     // Round to integer
1093   3                              //div     = 2;                                          // Output DPLL/2 for DCLK
1094   3                              //mcode   = (mcode + 1) >> 1;           // Round to integer
1095   3                      }
1096   2                      else
1097   2              {
1098   3                          div     = 1;                                        // Output DPLL for DCLK
1099   3                          mcode   = (mcode + 2) >> 2;         // Round to integer
1100   3                      }
1101   2              }
1102   1              else
1103   1          {
1104   2                      div     = 1;                                                    // Output DPLL for DCLK
1105   2                      mcode   = (mcode + 2) >> 2;             // Round to integer
1106   2              }               
1107   1                 
1108   1          // Original Formula : M_Code/Ich = 36.67 must be constant
1109   1          // Ich   = M_Code * 100 / 3667
1110   1          // Ich   = 1u + D0[0]*1u + D0[1]*2u + D0[2]*4u + D0[3]*8u (A)
1111   1      
1112   1          // Calculate the Ich,
1113   1          pData[5]    = ((WORD)mcode * 100 / 3667) - 1;
1114   1          pData[6]    = 0x00;
1115   1      
1116   1          if(pData[5] >= 8)
1117   1          {
1118   2              pData[5]    -= 8;
1119   2              pData[6]    |= 0x08;
1120   2          }
1121   1      
1122   1          if(pData[5] >= 4)
1123   1          {
1124   2              pData[5]    -= 4;
1125   2              pData[6]    |= 0x04;
1126   2          }
1127   1      
1128   1          if(pData[5] >= 2)
1129   1          {
1130   2              pData[5]    -= 2;
1131   2              pData[6]    |= 0x02;
1132   2          }
1133   1      
1134   1          if(pData[5] >= 1)
1135   1          {
1136   2              pData[5]    -= 1;
1137   2              pData[6]    |= 0x01;
1138   2          }
1139   1      
1140   1          pData[0]    = mcode - 2;
1141   1      #if(_M2PLL_USE == _ON)
                  pData[1]    = ((1 == div) ? 0x00 : 0x10) | ((_DPLL_N_CODE / _RTD_M2PLL_RATIO) - 2);
              #else
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 20  

1144   1              if((GET_PNL_OUTPUT_BUS() == _PANEL_TTL) || (Panel[ucPanelSelect]->DHWidth < 1100))
1145   1          {
1146   2                      if(div==2)
1147   2                              pData[1]    = 0x10 | (_DPLL_N_CODE - 2);
1148   2                      else if(div==4)
1149   2                              pData[1]    = 0x20 | (_DPLL_N_CODE - 2);        
1150   2                      else//div==1
1151   2                              pData[1]    = 0x00 | (_DPLL_N_CODE - 2);
1152   2              }
1153   1              else    
1154   1                      pData[1]    = ((1 == div) ? 0x00 : 0x10) | (_DPLL_N_CODE - 2);
1155   1      #endif
1156   1          pData[2]    = 0x80 | pData[6];
1157   1          pData[3]    = 0x17;
1158   1      
1159   1      #endif
1160   1      
1161   1          CScalerPageSelect(_PAGE1);
1162   1          CScalerWrite(_P1_DPLL_M_BF, 4, pData, _AUTOINC);
1163   1          CScalerSetBit(_P1_DPLL_OTHER_C3, ~_BIT1, _BIT1);
1164   1          if((bit)CScalerGetBit(_P1_DPLL_N_C0, _BIT7))
1165   1          {
1166   2              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, _BIT6);
1167   2              CTimerDelayXms(2);
1168   2              CScalerSetBit(_P1_DPLL_N_C0, ~_BIT6, 0x00);
1169   2          }
1170   1      
1171   1          // Dclk frequency in Hz
1172   1          ((DWORD *)pData)[0] = (DWORD)_RTD_XTAL * 1000 / (div * 2) * mcode / _DPLL_N_CODE;
1173   1      
1174   1          // Offset resolution (Dclk / 2^15) in Hz
1175   1          ((DWORD *)pData)[1] = ((DWORD *)pData)[0] >> 15;
1176   1      
1177   1          // Target frequency of Dclk in Hz
1178   1          mcode       = (((DWORD *)pData)[0] - (ulFreq * 1000)) / ((DWORD *)pData)[1];
1179   1          mcode       = mcode & 0x0fff;
1180   1      
1181   1              //Enable DDS spread spectrum output function
1182   1              CScalerSetBit(_P1_EVEN_FIXED_LAST_LINE_CTRL_CA, ~_BIT0, _BIT0);
1183   1      
1184   1          CAdjustDclkOffset(mcode);
1185   1      }
1186          
1187          //--------------------------------------------------
1188          // Description  :
1189          // Input Value  :
1190          // Output Value :
1191          //--------------------------------------------------
1192          void CAdjustUpdateCenterData(void)
1193          {
1194   1          WORD delta;
1195   1      
1196   1          stModeUserCenterData.CenterHPos     = stModeUserData.HPosition;
1197   1          stModeUserCenterData.CenterVPos     = stModeUserData.VPosition;
1198   1      
1199   1          CAdjustCheckAdcClockRange(stModeUserData.Clock, &delta);
1200   1      
1201   1          if(delta < _CLOCK_BIAS)
1202   1          {
1203   2              stModeUserCenterData.CenterClock = stModeInfo.IHTotal;
1204   2          }
1205   1          else
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 21  

1206   1          {
1207   2              if(stModeUserData.Clock < stModeInfo.IHTotal)
1208   2              {
1209   3                  if((stModeUserData.Clock - stModeInfo.IHTotal + delta) < _CLOCK_BIAS)
1210   3                  {
1211   4                      stModeUserCenterData.CenterClock = stModeInfo.IHTotal - delta + _CLOCK_BIAS;
1212   4                  }
1213   3                  else
1214   3                  {
1215   4                      stModeUserCenterData.CenterClock = stModeUserData.Clock;
1216   4                  }
1217   3              }
1218   2              else
1219   2              {
1220   3                  if((stModeInfo.IHTotal + delta - stModeUserData.Clock) < _CLOCK_BIAS)
1221   3                  {
1222   4                      stModeUserCenterData.CenterClock = stModeInfo.IHTotal + delta - _CLOCK_BIAS;
1223   4                  }
1224   3                  else
1225   3                  {
1226   4                      stModeUserCenterData.CenterClock = stModeUserData.Clock;
1227   4                  }
1228   3              }
1229   2          }
1230   1      }
1231          
1232          //--------------------------------------------------
1233          // Description  : Check if the ADC clock (IHTotal) is out of range. Range = (BackPorch + FrontPorch) * 2 /
             - 5 .
1234          // Input Value  : usClock   --> ADC Clock (IHTotal)
1235          // Output Value : Return _TRUE if not out of range
1236          //--------------------------------------------------
1237          bit CAdjustCheckAdcClockRange(WORD usClock, WORD *delta)
1238          {
1239   1          *delta   = (stModeInfo.IHTotal - stModeInfo.IHWidth * 8 / 10) / 2;
1240   1      
1241   1          if((usClock > stModeInfo.IHTotal) && ((usClock - stModeInfo.IHTotal) > *delta))
1242   1              return _FALSE;
1243   1      
1244   1          if((usClock <= stModeInfo.IHTotal) && ((stModeInfo.IHTotal - usClock) > *delta))
1245   1              return _FALSE;
1246   1      
1247   1          // yc 060222 for usClock error no display
1248   1          if(usClock < (stModeInfo.IHStartPos + _CAPTURE_HDELAY - (ucHStartBias + _PROGRAM_HDELAY) + stModeInfo.
             -IHWidth))
1249   1              return _FALSE;
1250   1      
1251   1          return _TRUE;
1252   1      }
1253          
1254          //080324
1255          #if(1)
1256          //--------------------------------------------------
1257          // Description  : Set ADC clock (IHTotal)
1258          // Input Value  : usClock   --> Target ADC clock
1259          // Output Value : None
1260          //--------------------------------------------------
1261          #define _G_VALUE_DIVIDER_0  4
1262          #define _G_VALUE_DIVIDER_1  16
1263          #define _G_VALUE_DIVIDER_2  64
1264          #define _G_VALUE_DIVIDER_3  128
1265          #define _G_VALUE_DIVIDER_4  256
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 22  

1266          #define _G_VALUE_DIVIDER_5  512
1267          
1268          //cyyeh 20080222 start
1269          void CAdjustAdcClock(WORD usClock , BYTE ucControl)
1270          {
1271   1              DWORD pllclock, icode;
1272   1              BYTE mcode;
1273   1              SBYTE STemp;
1274   1              WORD pcode;
1275   1              BYTE vco_divider = 2;
1276   1      
1277   1          if(ucControl == 1)
1278   1              CAdjustAPLLFastLock(usClock);
1279   1          else if(ucControl == 2)
1280   1              CAdjustAdcClock_OSD(usClock);
1281   1          else
1282   1          {
1283   2              CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
1284   2              CScalerPageSelect(_PAGE1);
1285   2      /********************************************************
1286   2      Fvco : Frequency of APLL
1287   2      Fxtal : Frequency of Crystal
1288   2      IHF : Input Horizontal Frequency
1289   2      usClock : Divider number of input clock
1290   2      stModeInfo.IHFreq = 10 * IHF(in KHz)
1291   2      _RTD_XTAl : Defined crystal clock unit in KHz
1292   2       
1293   2      Fvco = Fxtal*(M + K/16)/N1 = IHF * usClock * vco_divider
1294   2      Assum N1 = 2
1295   2      (M + K/16) = IHF * usClock * N1 * vco_divider / Fxtal
1296   2      stModeInfo.IHFreq UINT in 100Hz
1297   2      *********************************************************/
1298   2              //ADC sampling clock, UNIT in KHz
1299   2              pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;  
1300   2              vco_divider = pllclock < 100000 ? 4 : 2;   
1301   2              //Get (M + K/16) * 1024
1302   2              pllclock  = ((pllclock * _APLL_N_CODE * vco_divider) << 10 ) / _RTD_XTAL;
1303   2              CScalerPageSelect(_PAGE1);
1304   2              CScalerSetByte(_P1_PLL_DIV_CTRL_A0, 0x08);
1305   2              CScalerSetByte(_P1_DDS_MIX_2_B9, 0xff);
1306   2              CScalerSetByte(_P1_PLL_CRNT_AE, 0x65);
1307   2              CScalerSetBit(_P1_PLLDIV_H_B1, ~(_BIT6 | _BIT5 | _BIT4), (vco_divider == 2) ? (_BIT6 | _BIT5) : (_BI
             -T6 | _BIT5 | _BIT4));
1308   2              //Set the divide number
1309   2              CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1310   2              CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1311   2              CAdjustGetAPLLSetting(usClock);
1312   2              //Set N code
1313   2              CScalerSetBit(_P1_PLL_N_AD, 0xf8, ((_APLL_N_CODE - 2) & 0x07));
1314   2              //Get M, K code, M + K/16 = pllclock / 1024
1315   2              mcode = pllclock >> 10; //M is the integer part
1316   2              //CScalerSetByte(0x04,mcode );
1317   2              //K is the fraction part quantized by 16
1318   2              STemp = ((DWORD)pllclock - ((DWORD)mcode << 10)) >> 6;
1319   2              //K is range from -8 ~ 7
1320   2              if(STemp>7)
1321   2              {
1322   3                      mcode +=1;
1323   3                      STemp -= 16;
1324   3              }
1325   2              else if(STemp<(-8))
1326   2              {
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 23  

1327   3                      mcode -=1;
1328   3                      STemp += 16;
1329   3              }
1330   2              //set M, N, K code
1331   2              CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
1332   2              CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((STemp & 0x0f) << 4) | (_APLL_N_CODE - 2)));
1333   2              CScalerSetByte(0xA4, 0x80);
1334   2              CTimerDelayXms(1);
1335   2              CScalerRead(0xA4, 2, pData, _AUTOINC);
1336   2              usPEValue =  ( ((pData[0]&0x0F)<<8) | pData[1] );
1337   2              usPEValue = 1000000/(usPEValue*(_RTD_XTAL/1000));   // unit : ps
1338   2      /****************************************************************************
1339   2              Formula :
1340   2      
1341   2                I_gain       Ths                    PE(UNIT)                   1
1342   2              --------- x  ------- = ------------------------------------ x  -----
1343   2                 2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
1344   2      
1345   2                I_gain         Ths                      PE(UNIT)                   1
1346   2              --------- x  ----------- = ------------------------------------ x  -----
1347   2                 2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
1348   2      
1349   2                         2^22 x PE_U x (16M +- K)        1
1350   2              I_gain = ----------------------------- x -----
1351   2                                   Ths                   8
1352   2      
1353   2                  2^19 x PE_U x (16M +- K)   
1354   2              = -----------------------------
1355   2                            Ths              
1356   2      
1357   2              = IHF x 2^19 x PE_U x (16M +- K)
1358   2      ****************************************************************************/
1359   2      // (M + K/16) = pllclock / 1024
1360   2      // 16M + K = 16 * pllclock / 1024
1361   2      // 2^19 * 2^4 / 2^10 = 2^13
1362   2      // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
1363   2      // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
1364   2          /*
1365   2              icode = (DWORD)((stModeInfo.IHFreq) * usPEValue * pllclock) / (DWORD)1220702;
1366   2              icode &= 0x00007fff;
1367   2              CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
1368   2              CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
1369   2              // Set the P code
1370   2              pcode = (7 * icode * _RTD_XTAL / stModeInfo.IHFreq /_APLL_N_CODE) >> 7;
1371   2          //    pcode = 0xC0;
1372   2          //*/
1373   2          ///*    whhsiao 20080227 update-start
1374   2              icode = (DWORD)((stModeInfo.IHFreq) * usPEValue * pllclock) / (DWORD)1220703;
1375   2              //icode = icode>>2;   // n=32
1376   2              icode = icode>>6;   // n=512
1377   2              icode &= 0x00007fff;
1378   2          
1379   2              CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
1380   2              CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
1381   2          
1382   2              // Set the P code
1383   2              //pcode = (5 * icode * _RTD_XTAL / (stModeInfo.IHFreq/10) / _APLL_N_CODE ) >> 7;    // Total gain=
             -(1+5)/32
1384   2              pcode = (63 * icode * _RTD_XTAL / (stModeInfo.IHFreq/10) / _APLL_N_CODE ) >> 7;    // Total gain=(
             -1+63)/512
1385   2          //    pcode = 0xC0;
1386   2          //*/    whhsiao 20080227 update-end
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 24  

1387   2              if(pcode > 255)
1388   2              {
1389   3                      for(pData[0] = 9; pData[0] < 15; pData[0]++)
1390   3                      {
1391   4                              if((pcode >> pData[0]) == 0)
1392   4                                      break;
1393   4                      }
1394   3                  switch(pData[0]-9)//yc 20080225 
1395   3                  {
1396   4                      case 0:
1397   4                              pcode = pcode / _G_VALUE_DIVIDER_0;
1398   4                          break;
1399   4                      case 1:
1400   4                              pcode = pcode / _G_VALUE_DIVIDER_1;
1401   4                          break;
1402   4                      case 2:
1403   4                              pcode = pcode / _G_VALUE_DIVIDER_2;
1404   4                          break;
1405   4                      case 3:
1406   4                              pcode = pcode / _G_VALUE_DIVIDER_3;
1407   4                          break;
1408   4                      case 4:
1409   4                              pcode = pcode / _G_VALUE_DIVIDER_4;
1410   4                          break;
1411   4                      case 5:
1412   4                              pcode = pcode / _G_VALUE_DIVIDER_5;
1413   4                          break;
1414   4                      default:
1415   4                          break;
1416   4                  }
1417   3                      //pcode = pcode / g_value_divider[(pData[0] - 9)];
1418   3                      STemp = pData[0] - 7;
1419   3              }
1420   2          
1421   2              if(pcode==0)
1422   2              pcode = 1;
1423   2          
1424   2              //g_value = 0x01;
1425   2              CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, STemp << 2);
1426   2          
1427   2              CScalerSetByte(_P1_DDS_MIX_2_B9, 0x05); //set the P_code_max
1428   2              CScalerSetByte(_P1_DDS_MIX_3_BA, 0x1e);
1429   2              CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode);
1430   2          
1431   2              CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1432   2          
1433   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1434   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1435   2          
1436   2              pData[0] = 32;
1437   2              do
1438   2              {
1439   3                  CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1440   3                  CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1441   3                  CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1442   3          
1443   3                  CTimerWaitForEvent(_EVENT_IEN_STOP);
1444   3                  CTimerWaitForEvent(_EVENT_IEN_STOP);
1445   3          
1446   3              }while(CAdjustGetAPLLSetting(usClock) && --pData[0]);
1447   2          
1448   2              CPowerADCAPLLOn();
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 25  

1449   2              
1450   2          
1451   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1452   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1453   2              CTimerWaitForEvent(_EVENT_IEN_STOP);
1454   2          
1455   2              CAdjustGetAPLLSetting(usClock);
1456   2          
1457   2              CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x00);
1458   2          
1459   2              CMiscClearStatusRegister();
1460   2      
1461   2          }
1462   1      }
1463          
1464          void CAdjustAPLLFastLock(WORD usClock)
1465          {
1466   1          DWORD delta, pll_divider , pll_divider_k , pllclock , pll_divider_old ;
1467   1          BYTE mcode ;
1468   1          SBYTE kcode , delta_k , final_k , delta_m=0;
1469   1          DWORD sum_i_now;
1470   1          ///*    whhsiao 20080227 update-start
1471   1          SDWORD sum_i_now_temp[2]={0,0};
1472   1          BYTE  times;
1473   1          //*/    whhsiao 20080227 update-end
1474   1      
1475   1              //ADC sampling clock, UNIT in KHz
1476   1              pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;
1477   1          mcode = pllclock < 100000 ? 4 : 2;
1478   1          //Get (M + K/16) * 1024
1479   1          pll_divider_old  = (((pllclock * _APLL_N_CODE * mcode) << 10 ) / _RTD_XTAL) << 3;
1480   1          CScalerPageSelect(_PAGE1);
1481   1      /*
1482   1          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x04);
1483   1          CTimerDelayXms(1);
1484   1          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x03);
1485   1          CScalerRead(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1486   1      
1487   1          sum_i_now = ( (((DWORD)pData[0]<<24)&0x7000000) | (((DWORD)pData[1]<<16)&0xff0000)| (((DWORD)pData[2]<
             -<8)&0xff00) | ((DWORD)pData[3]&0xff)) ;
1488   1      */
1489   1      ///*    whhsiao 20080227 update-start
1490   1          for (times=0;times<10;times++)
1491   1          {
1492   2          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x04);
1493   2          CTimerDelayXms(1);
1494   2          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x03);
1495   2          CScalerRead(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1496   2      
1497   2          sum_i_now_temp[1] = ( (((DWORD)pData[0]<<24)&0x7000000) | (((DWORD)pData[1]<<16)&0xff0000)| (((DWORD)p
             -Data[2]<<8)&0xff00) | ((DWORD)pData[3]&0xff)) ;
1498   2      
1499   2          if ((sum_i_now_temp[1]>>26) ==1)
1500   2              sum_i_now_temp[1] = sum_i_now_temp[1] | 0xF8000000;
1501   2      
1502   2          sum_i_now_temp[0] += sum_i_now_temp[1];
1503   2          CTimerDelayXms(1);
1504   2          }
1505   1      
1506   1          if ( (sum_i_now_temp[0]>>31) == 1)
1507   1              sum_i_now = ((sum_i_now_temp[0]/(SBYTE)10)^0xFFFFFFFF)+1;
1508   1          else
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 26  

1509   1              sum_i_now = sum_i_now_temp[0]/(SBYTE)10;
1510   1      //*/    whhsiao 20080227 update-end
1511   1      
1512   1      
1513   1          // calculate Final K Value    
1514   1          delta_k =  sum_i_now >> 22;
1515   1      
1516   1          if ( (delta_k>>4) == 1 )
1517   1          {  
1518   2            delta_k |= 0xE0;
1519   2            delta_k +=1;
1520   2           }
1521   1      
1522   1          CScalerRead(0xAD, 1, pData, _NON_AUTOINC);
1523   1          kcode = (pData[0]>>4)&0x0f;
1524   1      
1525   1          if ( (kcode>>3) == 1 )
1526   1              kcode |= 0xF0;
1527   1      
1528   1          final_k = delta_k + kcode ;
1529   1      
1530   1      
1531   1          if (final_k < -16)
1532   1          {
1533   2              delta_m = -1;
1534   2              final_k +=16;
1535   2          }
1536   1          else if (final_k >15)
1537   1          {
1538   2              delta_m =1 ;
1539   2              final_k -=16;
1540   2          }
1541   1      
1542   1          
1543   1          final_k &= 0x0F;
1544   1      
1545   1          // calculate Sum_I
1546   1          delta = sum_i_now & 0x3fffff;   // 22bits
1547   1      
1548   1      
1549   1          // calculate Final M Value 
1550   1          CScalerRead(0xAC, 1, pData, _NON_AUTOINC);
1551   1          mcode = pData[0]+3;
1552   1      
1553   1          if (delta_m>0)
1554   1              mcode += 1;
1555   1          if (delta_m<0)
1556   1              mcode -= 1;
1557   1      
1558   1          pll_divider = (DWORD)mcode << 26;
1559   1      
1560   1          pll_divider_k = (DWORD)final_k << 22;
1561   1      
1562   1      
1563   1          if ( (final_k>>3) == 1 )                                 // final_k 2's 
1564   1              pll_divider_k = 0x4000000 - pll_divider_k;
1565   1      
1566   1      
1567   1          if ( (final_k>>3) == 1 )
1568   1              pll_divider =  pll_divider - pll_divider_k ;
1569   1          else
1570   1              pll_divider =  pll_divider + pll_divider_k ;
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 27  

1571   1      
1572   1      
1573   1          if ((sum_i_now>>26) ==1)                        // delta 2's
1574   1              delta = 0x400000 -  delta;       
1575   1        //  else
1576   1        //      delta = delta;
1577   1      
1578   1              
1579   1          if ((sum_i_now>>26) ==1)
1580   1              pll_divider = pll_divider - delta ;
1581   1          else
1582   1              pll_divider = pll_divider + delta ;
1583   1      
1584   1      
1585   1          usPllDivider =  pll_divider / usClock ;
1586   1          usPllDividerRem =  ((pll_divider % usClock) <<12) / usClock ;
1587   1      
1588   1          usIHFreqApllFast =  ((((DWORD)stModeInfo.IHFreq * (pll_divider>>11)) / pll_divider_old) + 2) >> 2;
1589   1        
1590   1      }
1591          //--------------------------------------------------
1592          // Description  : Set ADC clock (IHTotal)
1593          // Input Value  : usClock   --> Target ADC clock
1594          // Output Value : None
1595          //--------------------------------------------------
1596          void CAdjustAdcClock_OSD(WORD usClock)
1597          {
1598   1          DWORD delta, pll_divider;
1599   1          BYTE mcode;
1600   1          WORD pcode;
1601   1              SBYTE STemp ;
1602   1          CScalerPageSelect(_PAGE1);
1603   1      #if(_APLL_FAST_LOCK)
1604   1              //set the FAST PLL CONTROL
1605   1              CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT5 | _BIT1), (_BIT5 | _BIT1));
1606   1      #endif
1607   1          pll_divider = ((usPllDivider * usClock)) + ((usPllDividerRem * usClock)>>12);
1608   1          mcode = pll_divider >> 26;
1609   1          STemp = (pll_divider>>22) & 0x0F;
1610   1              if(STemp>7)
1611   1              {
1612   2                      mcode +=1;
1613   2                      STemp -= 16;
1614   2              }
1615   1              else if(STemp<(-8))  // Always False
1616   1              {
1617   2                      mcode -=1;
1618   2                      STemp += 16;
1619   2              }
1620   1          delta = pll_divider & 0x003FFFFF;
1621   1              CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1622   1              CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1623   1              CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
1624   1              CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((STemp & 0x0f) << 4) | (_APLL_N_CODE - 2)));
1625   1          pData[0] = 0x00;
1626   1              pData[1] = (BYTE)((delta >> 16) & 0x0000003f);
1627   1              pData[2] = (BYTE)((delta >> 8)  & 0x000000ff);
1628   1              pData[3] = (BYTE)((delta << 0)  & 0x000000ff);
1629   1              CScalerWrite(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1630   1      /****************************************************************************
1631   1          PE Calibration Function  // Added by whhsiao 20080213
1632   1      ****************************************************************************/
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 28  

1633   1          CScalerSetByte(0xA4, 0x80);
1634   1          CTimerDelayXms(1);
1635   1          CScalerRead(0xA4, 2, pData, _AUTOINC);
1636   1          usPEValue =  ( ((pData[0]&0x0F)<<8) | pData[1] );
1637   1          usPEValue = 1000000/(usPEValue*(_RTD_XTAL/1000));   // unit : ps
1638   1      /****************************************************************************
1639   1      
1640   1              Formula :
1641   1      
1642   1                I_gain       Ths                    PE(UNIT)                   1
1643   1              --------- x  ------- = ------------------------------------ x  -----
1644   1                 2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
1645   1      
1646   1                I_gain         Ths                      PE(UNIT)                   1
1647   1              --------- x  ----------- = ------------------------------------ x  -----
1648   1                 2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
1649   1      
1650   1                         2^22 x PE_U x (16M +- K)        1
1651   1              I_gain = ----------------------------- x -----
1652   1                                   Ths                   n
1653   1      
1654   1                  2^22 x PE_U x (16M +- K)        1
1655   1              = ----------------------------- x -----
1656   1                            Ths                   n
1657   1      
1658   1              = IHF x 2^22 x PE_U x (16M +- K) x 2^(-n)
1659   1      
1660   1      ****************************************************************************/
1661   1              // (M + K/16) = pllclock / 1024
1662   1              // 16M + K = 16 * pllclock / 1024
1663   1              // 2^19 * 2^4 / 2^10 = 2^13
1664   1              // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
1665   1              // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
1666   1          pll_divider = (usPEValue * (usIHFreqApllFast/10)) * (pll_divider/(DWORD)100000);  //yc 20080306 
1667   1          pll_divider = (pll_divider/10000) >> 9;    // 
1668   1          //pll_divider = (pll_divider/10000) >> 8;    // 
1669   1          pll_divider &= 0x00007fff;
1670   1              CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(pll_divider >> 8));
1671   1              CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)pll_divider);
1672   1              // Set the P code
1673   1              pcode = (WORD) ((63*pll_divider * (_RTD_XTAL/_APLL_N_CODE) / (usIHFreqApllFast/10) ) >> 7); // Total Gain
             - = 65/512
1674   1          STemp=1;
1675   1              if(pcode > 255)
1676   1              {
1677   2                      for(pData[0] = 9; pData[0] < 15; pData[0]++)
1678   2                      {
1679   3                              if((pcode >> pData[0]) == 0)
1680   3                                      break;
1681   3                      }
1682   2              switch(pData[0]-9)//yc 20080225 
1683   2              {
1684   3                  case 0:
1685   3                              pcode = pcode / _G_VALUE_DIVIDER_0;
1686   3                      break;
1687   3                  case 1:
1688   3                              pcode = pcode / _G_VALUE_DIVIDER_1;
1689   3                      break;
1690   3                  case 2:
1691   3                              pcode = pcode / _G_VALUE_DIVIDER_2;
1692   3                      break;
1693   3                  case 3:
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 29  

1694   3                              pcode = pcode / _G_VALUE_DIVIDER_3;
1695   3                      break;
1696   3                  case 4:
1697   3                              pcode = pcode / _G_VALUE_DIVIDER_4;
1698   3                      break;
1699   3                  case 5:
1700   3                              pcode = pcode / _G_VALUE_DIVIDER_5;
1701   3                      break;
1702   3                  default:
1703   3                      break;
1704   3              }
1705   2                      STemp = pData[0] - 7;
1706   2              }
1707   1          if(pcode==0x00)
1708   1              pcode = 0x01;
1709   1              CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, STemp << 2);
1710   1          CScalerSetByte(_P1_DDS_MIX_2_B9, 0xFF); //set the P_code_max
1711   1          CScalerSetByte(_P1_DDS_MIX_3_BA, 0xFF);
1712   1              CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode); 
1713   1      #if(_APLL_FAST_LOCK) //yc 20080225
1714   1          //CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5 | _BIT4), (_BIT6 | _BIT5 | _BIT4));
1715   1          CAdjustDisableWatchDog(_WD_APLL_NONLOCK);
1716   1          CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5), (_BIT6 | _BIT5));
1717   1          CTimerDelayXms(100); 
1718   1          CAdjustEnableWatchDog(_WD_APLL_NONLOCK);
1719   1      #else
                  //Enable Double buffer write in PLL M/N K¡BPLLDIV¡BDDS SUM_I
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~_BIT4, _BIT4);
              #endif
1723   1          CMiscClearStatusRegister();
1724   1      }
1725          
1726          // Eric 0617 add for YPbPr
1727          void CAdjustAdcClockYPbPr(WORD usClock)
1728          {
1729   1          //#define _PE_VALUE   175 // Unit: ps
1730   1          DWORD pllclock, icode, SUM_I;
1731   1          BYTE mcode;
1732   1          SBYTE kcode,g_value = 1;
1733   1          WORD delta, pcode;
1734   1          static BYTE vco_divider = 2;
1735   1          BYTE g_value_divider[6] = {4, 16, 64, 128, 256, 512};
1736   1      #if     (_APLL_FAST_LOCK)
1737   1          DWORD temp2662;
1738   1      #endif
1739   1      
1740   1      
1741   1              if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
1742   1              CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
1743   1          CScalerPageSelect(_PAGE1);
1744   1      
1745   1      #if(_APLL_FAST_LOCK)
1746   1              //set the FAST PLL CONTROL
1747   1              CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT5 | _BIT1), (_BIT5 | _BIT1));
1748   1      #endif
1749   1          /********************************************************
1750   1          Fvco : Frequency of APLL
1751   1          Fxtal : Frequency of Crystal
1752   1          IHF : Input Horizontal Frequency
1753   1          usClock : Divider number of input clock
1754   1          stModeInfo.IHFreq = 10 * IHF(in KHz)
1755   1          _RTD_XTAl : Defined crystal clock unit in KHz
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 30  

1756   1      
1757   1          Fvco = Fxtal*(M + K/16)/N1 = IHF * usClock * vco_divider
1758   1          Assum N1 = 2
1759   1          (M + K/16) = IHF * usClock * N1 * vco_divider / Fxtal
1760   1          stModeInfo.IHFreq UINT in 100Hz
1761   1          *********************************************************/
1762   1      
1763   1          //ADC sampling clock, UNIT in KHz
1764   1          pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;
1765   1      
1766   1          vco_divider = pllclock < 100000 ? 4 : 2;
1767   1      
1768   1          //Get (M + K/16) * 1024
1769   1          pllclock  = ((((pllclock * _APLL_N_CODE * vco_divider) << 4 )/(DWORD)(_RTD_XTAL)) << 6);
1770   1      
1771   1          CScalerPageSelect(_PAGE1);
1772   1          CScalerSetByte(_P1_PLL_DIV_CTRL_A0, 0x08);
1773   1      //  CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x24);  //Ming-Yen
1774   1      //  CScalerSetByte(_P1_PE_TRACKING_METHOD_B7, 0x02); //Ming-Yen
1775   1      //  CScalerSetByte(_P1_DDS_MIX_1_B8, 0x0c);   //Ming-Yen
1776   1          CScalerSetByte(_P1_DDS_MIX_2_B9, 0xff);
1777   1          CScalerSetByte(_P1_PLL_CRNT_AE, 0x63);
1778   1          
1779   1          //CScalerSetByte(_P1_PLL_WD_AF, 0x08);
1780   1      
1781   1          CScalerSetBit(_P1_PLLDIV_H_B1, ~(_BIT6 | _BIT5 | _BIT4), (vco_divider == 2) ? (_BIT6 | _BIT5) : (_BIT6
             - | _BIT5 | _BIT4));
1782   1      
1783   1             
1784   1      
1785   1          //Set the divide number
1786   1          CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1787   1          CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1788   1      
1789   1      
1790   1      ////////////////////////////////////////
1791   1            CAdjustGetAPLLSetting(usClock);
1792   1      ////////////////////////////////////////
1793   1      
1794   1      
1795   1          //Set N code
1796   1          CScalerSetBit(_P1_PLL_N_AD, 0xf8, ((_APLL_N_CODE - 2) & 0x07));
1797   1      
1798   1          //Get M, K code, M + K/16 = pllclock / 1024
1799   1          mcode = pllclock >> 10; //M is the integer part
1800   1          delta = (DWORD)pllclock - ((DWORD)mcode << 10);
1801   1      
1802   1          //K is the fraction part quantized by 16
1803   1          kcode = (delta) >> 6; 
1804   1      
1805   1      #if(_APLL_FAST_LOCK)
1806   1          //SUM_I is the truncated part by calculation quantized by 1024
1807   1              SUM_I = ((DWORD)delta << 4) - ((DWORD)kcode << 10); 
1808   1      #endif  
1809   1      
1810   1          //K is range from -8 ~ 7
1811   1          if(kcode>7)
1812   1          {
1813   2              mcode +=1;
1814   2              kcode -= 16;
1815   2          }
1816   1          else if(kcode<(-8))
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 31  

1817   1          {
1818   2              mcode -=1;
1819   2              kcode += 16;
1820   2          }
1821   1      
1822   1          //set M, N, K code
1823   1          CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
1824   1          CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((kcode & 0x0f) << 4) | (_APLL_N_CODE - 2)));
1825   1      
1826   1      #if (_APLL_FAST_LOCK)
1827   1              SUM_I = SUM_I << 12; // over flow need to modify
1828   1          //set SUM_I
1829   1              temp2662 = SUM_I & 0x07ffffff;
1830   1              pData[0] = (BYTE)((temp2662 >>24) & 0x000000ff);
1831   1              pData[1] = (BYTE)((temp2662 >>16) & 0x000000ff);
1832   1              pData[2] = (BYTE)((temp2662 >>8) & 0x000000ff);
1833   1              pData[3] = (BYTE)(temp2662 & 0x000000ff);
1834   1              CScalerWrite(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
1835   1      #endif
1836   1      
1837   1      
1838   1      /****************************************************************************
1839   1      
1840   1          Formula :
1841   1      
1842   1            I_gain       Ths                    PE(UNIT)                   1
1843   1          --------- x  ------- = ------------------------------------ x  -----
1844   1             2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
1845   1      
1846   1            I_gain         Ths                      PE(UNIT)                   1
1847   1          --------- x  ----------- = ------------------------------------ x  -----
1848   1             2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
1849   1      
1850   1                     2^22 x PE_U x (16M +- K)        1
1851   1          I_gain = ----------------------------- x -----
1852   1                               Ths                   8
1853   1      
1854   1              2^19 x PE_U x (16M +- K)
1855   1          = -----------------------------
1856   1                        Ths
1857   1      
1858   1          = IHF x 2^19 x PE_U x (16M +- K)
1859   1      
1860   1      ****************************************************************************/
1861   1      
1862   1          // (M + K/16) = pllclock / 1024
1863   1          // 16M + K = 16 * pllclock / 1024
1864   1          // 2^19 * 2^4 / 2^10 = 2^13
1865   1          // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
1866   1          // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
1867   1      
1868   1          icode = (DWORD)((stModeInfo.IHFreq) * 120/*usPEValue*/ * pllclock)/(DWORD)1220702;
1869   1          icode &= 0x00007fff;
1870   1      
1871   1          CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
1872   1          CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
1873   1      
1874   1          // Set the P code
1875   1          pcode = (7 * icode * _RTD_XTAL / stModeInfo.IHFreq /_APLL_N_CODE) >> 7;
1876   1          
1877   1          if(pcode > 255)
1878   1          {
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 32  

1879   2              for(pData[0] = 9; pData[0] < 15; pData[0]++)
1880   2              {
1881   3                  if((pcode >> pData[0]) == 0)
1882   3                      break;
1883   3              }
1884   2              pcode = pcode / g_value_divider[(pData[0] - 9)];
1885   2              g_value = pData[0] - 7;
1886   2          }
1887   1      
1888   1          CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, g_value << 2);
1889   1          CScalerSetByte(_P1_DDS_MIX_2_B9, 0x05); //set the P_code_max
1890   1          CScalerSetByte(_P1_DDS_MIX_3_BA, 0x1e);
1891   1          CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode);
1892   1      
1893   1      #if (_APLL_FAST_LOCK)
1894   1              //CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x60);
1895   1              CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5 | _BIT3), (_BIT6 | _BIT5 | _BIT3));
1896   1      #else
                  //Enable Double buffer write in PLL M/N K¡BPLLDIV¡BDDS SUM_I
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~_BIT4, _BIT4);
              #endif
1900   1      
1901   1          CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1902   1      
1903   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1904   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1905   1      
1906   1          pData[0] = 32;
1907   1          do
1908   1          {
1909   2              CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
1910   2              CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
1911   2              CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
1912   2      
1913   2           //   CTimerWaitForEvent(_EVENT_IEN_STOP);
1914   2             // CTimerWaitForEvent(_EVENT_IEN_STOP);
1915   2      
1916   2          }while(CAdjustGetAPLLSetting(usClock) && --pData[0]);
1917   1      
1918   1          CPowerADCAPLLOn();
1919   1          //DebugPrintf("\n CPowerADCAPLLOn ... ",0x20);
1920   1          
1921   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1922   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1923   1          CTimerWaitForEvent(_EVENT_IEN_STOP);
1924   1              
1925   1          CAdjustGetAPLLSetting(usClock);
1926   1              
1927   1          CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x00);
1928   1              
1929   1          CMiscClearStatusRegister();
1930   1              
1931   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
1932   1             CAdjustEnableWatchDog(_WD_ALL);
1933   1      }
1934          
1935          #else
              
              //--------------------------------------------------
              // Description  : Set ADC clock (IHTotal)
              // Input Value  : usClock   --> Target ADC clock
              // Output Value : None
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 33  

              //--------------------------------------------------
              void CAdjustAdcClock(WORD usClock)
              {
                  //#define _PE_VALUE   175 // Unit: ps
                  DWORD pllclock, icode, SUM_I;
                  BYTE mcode;
                  SBYTE kcode,g_value = 1;
                  WORD delta, pcode;
                  static BYTE vco_divider = 2;
                  BYTE g_value_divider[6] = {4, 16, 64, 128, 256, 512};
              #if     (_APLL_FAST_LOCK)
                  DWORD temp2662;
              #endif
              
              
                      if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
                      CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
                  CScalerPageSelect(_PAGE1);
              
              #if(_APLL_FAST_LOCK)
                      //set the FAST PLL CONTROL
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT5 | _BIT1), (_BIT5 | _BIT1));
              #endif
                  /********************************************************
                  Fvco : Frequency of APLL
                  Fxtal : Frequency of Crystal
                  IHF : Input Horizontal Frequency
                  usClock : Divider number of input clock
                  stModeInfo.IHFreq = 10 * IHF(in KHz)
                  _RTD_XTAl : Defined crystal clock unit in KHz
              
                  Fvco = Fxtal*(M + K/16)/N1 = IHF * usClock * vco_divider
                  Assum N1 = 2
                  (M + K/16) = IHF * usClock * N1 * vco_divider / Fxtal
                  stModeInfo.IHFreq UINT in 100Hz
                  *********************************************************/
              
                  //ADC sampling clock, UNIT in KHz
                  pllclock = (DWORD)stModeInfo.IHFreq * usClock / 10;
              
                  vco_divider = pllclock < 100000 ? 4 : 2;
              
                  //Get (M + K/16) * 1024
                  pllclock  = ((((pllclock * _APLL_N_CODE * vco_divider) << 4 )/(DWORD)(_RTD_XTAL)) << 6);
              
                  CScalerPageSelect(_PAGE1);
                  CScalerSetByte(_P1_PLL_DIV_CTRL_A0, 0x08);
              //  CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x24);  //Ming-Yen
              //  CScalerSetByte(_P1_PE_TRACKING_METHOD_B7, 0x02); //Ming-Yen
              //  CScalerSetByte(_P1_DDS_MIX_1_B8, 0x0c);   //Ming-Yen
                  CScalerSetByte(_P1_DDS_MIX_2_B9, 0xff);
                  CScalerSetByte(_P1_PLL_CRNT_AE, 0x63);
                  
                  //CScalerSetByte(_P1_PLL_WD_AF, 0x08);
              
                  CScalerSetBit(_P1_PLLDIV_H_B1, ~(_BIT6 | _BIT5 | _BIT4), (vco_divider == 2) ? (_BIT6 | _BIT5) : (_BIT6
             - | _BIT5 | _BIT4));
              
                     
              
                  //Set the divide number
                  CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 34  

                  CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
              
              
              ////////////////////////////////////////
                    CAdjustGetAPLLSetting(usClock);
              ////////////////////////////////////////
              
              
                  //Set N code
                  CScalerSetBit(_P1_PLL_N_AD, 0xf8, ((_APLL_N_CODE - 2) & 0x07));
              
                  //Get M, K code, M + K/16 = pllclock / 1024
                  mcode = pllclock >> 10; //M is the integer part
                  delta = (DWORD)pllclock - ((DWORD)mcode << 10);
              
                  //K is the fraction part quantized by 16
                  kcode = (delta) >> 6; 
              
              #if(_APLL_FAST_LOCK)
                  //SUM_I is the truncated part by calculation quantized by 1024
                      SUM_I = ((DWORD)delta << 4) - ((DWORD)kcode << 10); 
              #endif  
              
                  //K is range from -8 ~ 7
                  if(kcode>7)
                  {
                      mcode +=1;
                      kcode -= 16;
                  }
                  else if(kcode<(-8))
                  {
                      mcode -=1;
                      kcode += 16;
                  }
              
                  //set M, N, K code
                  CScalerSetByte(_P1_PLL_M_AC, (mcode - 3)); 
                  CScalerSetBit(_P1_PLL_N_AD, 0x0f, (((kcode & 0x0f) << 4) | (_APLL_N_CODE - 2)));
              
              #if (_APLL_FAST_LOCK)
                      SUM_I = SUM_I << 12; // over flow need to modify
                  //set SUM_I
                      temp2662 = SUM_I & 0x07ffffff;
                      pData[0] = (BYTE)((temp2662 >>24) & 0x000000ff);
                      pData[1] = (BYTE)((temp2662 >>16) & 0x000000ff);
                      pData[2] = (BYTE)((temp2662 >>8) & 0x000000ff);
                      pData[3] = (BYTE)(temp2662 & 0x000000ff);
                      CScalerWrite(_P1_FAST_PLL_ISUM_AB, 4, pData, _NON_AUTOINC);
              #endif
              
              
              /****************************************************************************
              
                  Formula :
              
                    I_gain       Ths                    PE(UNIT)                   1
                  --------- x  ------- = ------------------------------------ x  -----
                     2^22        Tbck        Txclk x 16N/(16M +- K) x 1/16         8
              
                    I_gain         Ths                      PE(UNIT)                   1
                  --------- x  ----------- = ------------------------------------ x  -----
                     2^22       Tclk x N         Txclk x 16N/(16M +- K) x 1/16         8
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 35  

              
                             2^22 x PE_U x (16M +- K)        1
                  I_gain = ----------------------------- x -----
                                       Ths                   8
              
                      2^19 x PE_U x (16M +- K)
                  = -----------------------------
                                Ths
              
                  = IHF x 2^19 x PE_U x (16M +- K)
              
              ****************************************************************************/
              
                  // (M + K/16) = pllclock / 1024
                  // 16M + K = 16 * pllclock / 1024
                  // 2^19 * 2^4 / 2^10 = 2^13
                  // _PE_VALUE UNIT is ps, so result has to multiply 10^(-12)
                  // stModeInfo.IHFreq/10 UNIT is KHz, so result has to multiply 10^2
              
                  icode = (DWORD)((stModeInfo.IHFreq) * 120/*usPEValue*/ * pllclock)/(DWORD)1220702;
                  icode &= 0x00007fff;
              
                  CScalerSetByte(_P1_I_CODE_M_A1,(BYTE)(icode >> 8));
                  CScalerSetByte(_P1_I_CODE_L_A2, (BYTE)icode);
              
                  // Set the P code
                  pcode = (7 * icode * _RTD_XTAL / stModeInfo.IHFreq /_APLL_N_CODE) >> 7;
                  
                  if(pcode > 255)
                  {
                      for(pData[0] = 9; pData[0] < 15; pData[0]++)
                      {
                          if((pcode >> pData[0]) == 0)
                              break;
                      }
                      pcode = pcode / g_value_divider[(pData[0] - 9)];
                      g_value = pData[0] - 7;
                  }
              
                  CScalerSetByte(_P1_P_CODE_MAPPING_METHOD_B6, g_value << 2);
                  CScalerSetByte(_P1_DDS_MIX_2_B9, 0x05); //set the P_code_max
                  CScalerSetByte(_P1_DDS_MIX_3_BA, 0x1e);
                  CScalerSetByte(_P1_P_CODE_A3, (BYTE)pcode);
              
              #if (_APLL_FAST_LOCK)
                      //CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x60);
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~(_BIT6 | _BIT5 | _BIT3), (_BIT6 | _BIT5 | _BIT3));
              #else
                  //Enable Double buffer write in PLL M/N K¡BPLLDIV¡BDDS SUM_I
                      CScalerSetBit(_P1_FAST_PLL_CTRL_AA, ~_BIT4, _BIT4);
              #endif
              
                  CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
              
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
              
                  pData[0] = 32;
                  do
                  {
                      CScalerSetBit(_P1_PLLDIV_H_B1, 0xf0, (BYTE)(((usClock - 1) >> 8) & 0x0f));
                      CScalerSetByte(_P1_PLLDIV_L_B2, (BYTE)((usClock - 1) & 0x00ff));
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 36  

                      CScalerSetByte(_P1_PLLPHASE_CTRL1_B4, 0x00);
              
                   //   CTimerWaitForEvent(_EVENT_IEN_STOP);
                     // CTimerWaitForEvent(_EVENT_IEN_STOP);
              
                  }while(CAdjustGetAPLLSetting(usClock) && --pData[0]);
              
                  CPowerADCAPLLOn();
                  //DebugPrintf("\n CPowerADCAPLLOn ... ",0x20);
                  
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                  CTimerWaitForEvent(_EVENT_IEN_STOP);
                      
                  CAdjustGetAPLLSetting(usClock);
                      
                  CScalerSetByte(_P1_FAST_PLL_CTRL_AA, 0x00);
                      
                  CMiscClearStatusRegister();
                      
                      if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
                     CAdjustEnableWatchDog(_WD_ALL);
              }
              
              #endif
2151          
2152          
2153          //--------------------------------------------------
2154          // Description  : Get APLL Setting
2155          // Input Value  : usClock   --> Target ADC clock
2156          // Output Value : None
2157          //--------------------------------------------------
2158          BYTE CAdjustGetAPLLSetting(WORD usClock)
2159          {
2160   1          BYTE ucTemp[2];
2161   1      
2162   1              usClock -= 1;
2163   1          
2164   1          CScalerPageSelect(_PAGE1);
2165   1          CScalerRead(_P1_PLLDIV_H_B1, 2, ucTemp, _AUTOINC);
2166   1      
2167   1              ucTemp[0] &= 0x0f;
2168   1      
2169   1              if((ucTemp[0] != (BYTE)(usClock >> 8)) || (ucTemp[1] != (BYTE)(usClock & 0x00ff)))
2170   1              {
2171   2                      return _TRUE;
2172   2              }
2173   1              else
2174   1              {
2175   2                      return _FALSE;
2176   2              }
2177   1      }
2178          
2179          
2180          //--------------------------------------------------
2181          // Description  : Set phase
2182          // Input Value  : ucPhase   --> Target phase, ucPhase = N, N = 0 ~ 63
2183          // Output Value : None
2184          //--------------------------------------------------
2185          void CAdjustPhase(BYTE ucPhase)
2186          {
2187   1      #if(1)
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 37  

2188   1          BYTE ctrl, select;
2189   1              //DebugPrintf("\n CAdjustPhase %c",'!');
2190   1              
2191   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2192   1             CAdjustEnableWatchDog(_WD_DV_TIMEOUT_APLL_NONLOCK);
2193   1      
2194   1              //Ida added for change range from 0-63 to 0-100
2195   1               ucPhase = ucPhase & 0x3f;
2196   1              //ucPhase = ((WORD)(ucPhase*64)/101) & 0x3f;
2197   1      
2198   1          // Code below is to select stable HSYNC latch edge.
2199   1          // There is about 2.025ns delay for RTD2553V between input clock into ADC and output from ADC.
2200   1          // Calculating the corresponding phase delay for 2.025ns
2201   1          // Original Formula :
2202   1              // select = 64 * 2.025 * ulRate / 1000000;
2203   1      
2204   1          //select = (DWORD)_RTD_XTAL * stModeInfo.IHTotal / stModeInfo.IHCount * 130 / 1000000;
2205   1          select = (DWORD)_RTD_XTAL * stModeInfo.IHTotal / stModeInfo.IHCount * 389 / 1000000;
2206   1      
2207   1          select = (select <= 64) ? (64 - select) : (128 - select);
2208   1      
2209   1          // Calculate the absolute value from the selected phase to transition
2210   1          pData[0]    = (ucPhase >= select) ? ucPhase - select : select - ucPhase;
2211   1          ctrl        = (pData[0] > 12 && pData[0] < 52) ? 0x00 : 0x01;
2212   1      
2213   1          if((stModeInfo.IHStartPos < stModeUserData.HPosition) && ((stModeUserData.HPosition - stModeInfo.IHSta
             -rtPos) > ucHStartBias))
2214   1              stModeUserData.HPosition = stModeInfo.IHStartPos + ucHStartBias;
2215   1      
2216   1          if((stModeInfo.IHStartPos > stModeUserData.HPosition) && ((stModeInfo.IHStartPos - stModeUserData.HPos
             -ition) > ucHStartBias))
2217   1              stModeUserData.HPosition = stModeInfo.IHStartPos - ucHStartBias;
2218   1      
2219   1      //    pData[0]    = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDELAY;
2220   1          ((WORD *)pData)[0]  = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDEL
             -AY;
2221   1      
2222   1      
2223   1          // Compensate the H position shift due to the phase select
2224   1          if (select > 12)
2225   1              select  = ((ucPhase + 12) < select) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
2226   1          else
2227   1              select  = (ucPhase < (select + 52)) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
2228   1      
2229   1          CScalerPageSelect(_PAGE1);
2230   1      
2231   1          CScalerSetBit(_P1_PLLDIV_H_B1, ~_BIT6, _BIT6);
2232   1          if(((DWORD)stModeInfo.IHFreq * stModeInfo.IHTotal / 1000) < 530)
2233   1          {
2234   2              CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase * 2);           // Set phase
2235   2          }
2236   1          else
2237   1          {
2238   2              CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase);               // Set phase
2239   2          }
2240   1      
2241   1          CAdjustIHSDelay(select);                                        // Compensate IHS delay
2242   1          CScalerSetBit(_VGIP_DELAY_CTRL_12, ~_BIT3, (ctrl << 3));        // Select a correct edge to latch the 
             -stable data
2243   1          
2244   1          CMiscApplyDoubleBuffer();
2245   1                      
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 38  

2246   1          CMiscClearStatusRegister();
2247   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2248   1             CAdjustEnableWatchDog(_WD_ALL);
2249   1      #else
                  BYTE ctrl, select;
                  BYTE pllclock;
                  //DebugPrintf("\n CAdjustPhase %c",'!');
                  
                  if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)  // for Aspect ratio,hill 20070515  
                  CAdjustEnableWatchDog(_WD_DV_TIMEOUT);
                  
                  //Ida added for change range from 0-63 to 0-100
                  ucPhase = ucPhase & 0x3f;
               
                  pllclock = (DWORD)stModeInfo.IHFreq * stModeUserData.Clock / 10000;
                  if(pllclock < 113)
                      select = (138+pllclock)/4;
                  else
                      select = (pllclock-113)/3;
               
               
                  // Calculate the absolute value from the selected phase to transition
                  pData[0]    = (ucPhase >= select) ? ucPhase - select : select - ucPhase;
                  ctrl = (pData[0] > 12 && pData[0] < 52) ? 0x00 : 0x01;
               
                  if((stModeInfo.IHStartPos < stModeUserData.HPosition) && ((stModeUserData.HPosition - stModeInfo.IHSta
             -rtPos) > ucHStartBias))
                      stModeUserData.HPosition = stModeInfo.IHStartPos + ucHStartBias;
               
                  if((stModeInfo.IHStartPos > stModeUserData.HPosition) && ((stModeInfo.IHStartPos - stModeUserData.HPos
             -ition) > ucHStartBias))
                      stModeUserData.HPosition = stModeInfo.IHStartPos - ucHStartBias;
               
              //    pData[0]    = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDELAY;
                  ((WORD *)pData)[0]  = ucHStartBias + stModeInfo.IHStartPos - stModeUserData.HPosition  + _PROGRAM_HDEL
             -AY;
               
              
                  // Compensate the H position shift due to the phase select
                  if (select > 12)
                      select  = ((ucPhase + 12) < select) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
                  else
                      select  = (ucPhase < (select + 52)) ? (((WORD *)pData)[0] - 1) : ((WORD *)pData)[0];
                  CScalerPageSelect(_PAGE1);
               
                  CScalerSetBit(_P1_PLLDIV_H_B1, ~_BIT6, _BIT6);
               
                  if((bit)CScalerGetBit(_P1_PLLDIV_H_B1, _BIT4))
                  {
                      CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase * 2);           // Set phase
                  }
                  else
                  {
                      CScalerSetBit(_P1_PLLPHASE_CTRL1_B4, 0x80, ucPhase);               // Set phase
                  }
               
                  CAdjustIHSDelay(select);                                        // Compensate IHS delay
                  CScalerSetBit(_VGIP_DELAY_CTRL_12, ~_BIT3, (ctrl << 3));        // Select a correct edge to latch the 
             -stable data
                  
                  CMiscApplyDoubleBuffer();
                
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 39  

                  CMiscClearStatusRegister();
                
                  if(bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)  // for Aspect ratio,hill 20070515  
                      CAdjustEnableWatchDog(_WD_DV_TIMEOUT | _WD_FRAMESYNC);
              #endif
2309   1      }
2310          
2311          //--------------------------------------------------
2312          // Description  : Set H Position
2313          // Input Value  : None
2314          // Output Value : None
2315          //--------------------------------------------------
2316          void CAdjustHPosition(void)
2317          {
2318   1          // Update IHS delay according to phase
2319   1          CAdjustPhase(stModeUserData.Phase);
2320   1      }
2321          
2322          //--------------------------------------------------
2323          // Description  : Set V Position
2324          // Input Value  : None
2325          // Output Value : None
2326          //--------------------------------------------------
2327          void CAdjustVPosition(void)
2328          {
2329   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2330   1             CAdjustEnableWatchDog(_WD_APLL_NONLOCK);
2331   1      
2332   1          if((stModeInfo.IVStartPos < stModeUserData.VPosition) && ((stModeUserData.VPosition - stModeInfo.IVSta
             -rtPos) > ucVStartBias))
2333   1          {
2334   2              stModeUserData.VPosition = stModeInfo.IVStartPos + ucVStartBias;
2335   2          }
2336   1      
2337   1      #if(_V_POSITION_DIRECTION == _V_POSITION_METHOD_0)
2338   1      
2339   1          CAdjustIVSDelay(ucVStartBias + stModeInfo.IVStartPos - stModeUserData.VPosition + _PROGRAM_VDELAY);
2340   1      
2341   1      #endif
2342   1      
2343   1      #if(_V_POSITION_DIRECTION == _V_POSITION_METHOD_1)
              
                  CAdjustIVSDelay(ucVStartBias - (stModeInfo.IVStartPos - stModeUserData.VPosition) + _PROGRAM_VDELAY);
              
              #endif
2348   1      
2349   1          CMiscApplyDoubleBuffer();
2350   1      
2351   1          CTimerWaitForEvent(_EVENT_DEN_STOP);
2352   1          CTimerWaitForEvent(_EVENT_DEN_START);
2353   1      
2354   1          CMiscClearStatusRegister();
2355   1              if (bDoAspectRatioFlag == _FALSE && bDoAutoConfigFlag == _FALSE)
2356   1             CAdjustEnableWatchDog(_WD_ALL);
2357   1      }
2358          
2359          //--------------------------------------------------
2360          // Description  : Adjust Digital Filter
2361          // Input Value  : None
2362          // Output Value : None
2363          //--------------------------------------------------
2364          void CAdjustDigitalFilter(BYTE ucAccess, BYTE ucOffset, BYTE ucDiv, BYTE ucEnable)
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 40  

2365          {
2366   1          pData[0] = ((ucAccess & 0x0f) << 4) | 0x00;
2367   1      
2368   1          if(ucAccess == _YPBPR_ACCESS_PORT)
2369   1          {
2370   2              pData[1] = ((ucOffset & 0x07) << 5) | 0x10;
2371   2          }
2372   1          else
2373   1          {
2374   2              pData[1] = ((ucEnable & 0x01) << 7) | ((ucOffset & 0x07) << 4) | ((ucDiv & 0x03) << 2);
2375   2          }
2376   1      
2377   1          CScalerWrite(_DIGITAL_FILTER_CTRL_98, 2, pData, _AUTOINC);
2378   1      
2379   1          CScalerSetByte(_DIGITAL_FILTER_CTRL_98, 0x00);
2380   1      }
2381          
2382          void CAdjustSetYpbprRhue(void)
2383          {
2384   1              CScalerSetBit(_COLOR_CTRL_62,0xc7,0x08);
2385   1              CScalerWrite(_SRGB_ACCESS_PORT_63, 6, pData, _NON_AUTOINC);
2386   1      }
2387          
2388          void CAdjustSetYpbprGhue(void)
2389          {
2390   1              CScalerSetBit(_COLOR_CTRL_62,0xc7,0x10);
2391   1              CScalerWrite(_SRGB_ACCESS_PORT_63, 6, pData, _NON_AUTOINC);
2392   1      }
2393          
2394          void CAdjustSetYpbprBhue(void)
2395          {
2396   1              CScalerSetBit(_COLOR_CTRL_62,0xc7,0x18);
2397   1              CScalerWrite(_SRGB_ACCESS_PORT_63, 6, pData, _NON_AUTOINC);
2398   1      }
2399          
2400          
2401          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_YPBPR_SUPPORT == _ON))
2402          void CAdjustInterlaceIVS2DVSProtection(void)
2403          {
2404   1              WORD ustemp;
2405   1              BYTE temp;
2406   1      
2407   1              CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
2408   1              if(pData[0] & 0x20)
2409   1              {
2410   2            //  CScalerSetBit(_SCALE_CTRL_32, ~(_BIT7 | _BIT6), _BIT7); //forster modified 061102 
2411   2              //CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT0, _BIT0);
2412   2      
2413   2      //V400 modify
2414   2              CScalerRead(_IV_DV_DELAY_CLK_ODD_41, LENGTH(1), &temp, _NON_AUTOINC);
2415   2              ustemp = (WORD)temp * 16 + 16;
2416   2      
2417   2              if(ustemp > (stModeInfo.IHTotal / 2))
2418   2              {
2419   3                  ustemp -= stModeInfo.IHTotal / 2;
2420   3                  CScalerSetByte(_IV_DV_DELAY_CLK_EVEN_42, (ustemp - 16) / 16);
2421   3              }
2422   2              else
2423   2              {
2424   3                  CScalerSetByte(_IPV_ACT_STA_L_19, CScalerGetBit(_IPV_ACT_STA_L_19, 0xff) + 1);
2425   3                  ustemp += stModeInfo.IHTotal;
2426   3                  CScalerSetByte(_IV_DV_DELAY_CLK_ODD_41, (ustemp - 16) / 16);
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 41  

2427   3                  ustemp -= stModeInfo.IHTotal / 2;
2428   3                  CScalerSetByte(_IV_DV_DELAY_CLK_EVEN_42, (ustemp - 16) / 16);
2429   3              } 
2430   2      //V400 modify  
2431   2              CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~(_BIT1), _BIT1);       
2432   2              }
2433   1      }
2434          #endif
2435          
2436          #if(_HDMI_SUPPORT == _ON)
2437          //730702***
2438          void CAdjustHdmiCbCr422(void)
2439          {
2440   1              if(stModeInfo.IVHeight <= 288)
2441   1              {
2442   2                      CScalerPageSelect(_PAGE2);
2443   2                      CScalerGetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_ACRCR_51, 1, pData, _NON_AUTOINC);
2444   2                      CScalerPageSelect(_PAGE0);
2445   2                      if((pData[0] & 0x30) == 0x10)
2446   2                      {               
2447   3                              CTimerWaitForEvent(_EVENT_IVS);
2448   3                              pData[0] = HIBYTE(stModeInfo.IHTotal - 2);
2449   3                              pData[1] = 0x02;
2450   3                              pData[2] = LOBYTE(stModeInfo.IHTotal - 2);
2451   3                              pData[3] = HIBYTE(stModeInfo.IVTotal - 2);
2452   3                              pData[4] = 0x02;
2453   3                              pData[5] = LOBYTE(stModeInfo.IVTotal - 2);
2454   3                              pData[6] = 0x00;
2455   3                              pData[7] = 0x00;
2456   3                              pData[8] = 0x00;
2457   3                              pData[9] = 0x00;
2458   3                              pData[10] = 0x03;
2459   3                              pData[11] = 0x00;
2460   3                              pData[12] = 0x00;
2461   3                              pData[13] = 0x81;
2462   3                              CScalerWrite(_H_BOUNDARY_H_70, 14, pData, _AUTOINC);
2463   3                              pData[0]    = CAutoWaitFinish();
2464   3                              //if(pData[0] != _ERROR_SUCCESS)
2465   3                              //DebugPrintf("\nmeasure result = %x",pData[0]);        
2466   3      
2467   3                              CScalerRead(_V_START_END_H_7E, 6, pData, _AUTOINC);
2468   3                              usHStartPos = (((WORD) pData[3] & 0xf0) << 4) | (WORD) pData[4];
2469   3                              usHEndPos = (((WORD) pData[3] & 0x0f) << 8) | (WORD) pData[5];
2470   3                              usVStartPos = (((WORD) pData[0] & 0xf0) << 4) | (WORD) pData[1];
2471   3                              usVEndPos = (((WORD) pData[0] & 0x0f) << 8) | (WORD) pData[2];                  
2472   3      
2473   3                              pData[0]    = ((usHStartPos >> 4) & 0x70) | (HIBYTE(usHStartPos) & 0x0f);
2474   3                              pData[1]    = (LOBYTE(usHStartPos)+0);
2475   3                              pData[2]    = (LOBYTE(usHStartPos)+0);
2476   3                              pData[3]    = (HIBYTE(usVStartPos) & 0x0f);
2477   3                              pData[4]    = (LOBYTE(usVStartPos)+0);
2478   3                              pData[5]    = (LOBYTE(usVStartPos)+0);
2479   3                              CScalerWrite(_H_BOUNDARY_H_70, 6, pData, _AUTOINC);     
2480   3      
2481   3                              CScalerSetByte(_AUTO_ADJ_CTRL1_7D, 0x20);
2482   3              
2483   3                              CScalerSetByte(_AUTO_ADJ_CTRL0_7A, 0x00|_BIT1);//red    
2484   3                              CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~_BIT0 , _BIT0);//start
2485   3      
2486   3                              pData[0] = CAutoWaitFinish();
2487   3                              //if(pData[0] != _ERROR_SUCCESS)       
2488   3                                      //DebugPrintf("\nmeasureMAX_R result = %x",pData[0]);
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 42  

2489   3      
2490   3                              CScalerRead(_AUTO_PHASE_0_87, 1, &pData[1], _AUTOINC);
2491   3                              //DebugPrintf("\n****RED**** = %x",pData[1]);
2492   3              
2493   3                              CScalerSetByte(_AUTO_ADJ_CTRL0_7A, 0x00);//blue 
2494   3                              CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~_BIT0 , _BIT0);//start
2495   3      
2496   3                              pData[0] = CAutoWaitFinish();
2497   3                              //if(pData[0] != _ERROR_SUCCESS)       
2498   3                                      //DebugPrintf("\nmeasureMAX_B result = %x",pData[0]);
2499   3      
2500   3                              CScalerRead(_AUTO_PHASE_0_87, 1, &pData[2], _AUTOINC);
2501   3                              //DebugPrintf("\n****BLUE**** = %x",pData[2]);  
2502   3      
2503   3                              if((pData[1] != 0) || (pData[2] != 0))
2504   3                              {
2505   4                                      //DebugPrintf("\n\n=========MODIFY!!!!=========  \n\n",'0');
2506   4                      CScalerRead(_IPH_ACT_STA_L_15, 1, pData, _NON_AUTOINC);                 
2507   4                                      pData[0] = pData[0] - 1 ;
2508   4                                      CScalerSetBit(_VGIP_CTRL_10, ~_BIT4 , 0x00);
2509   4                                      CScalerSetByte(_IPH_ACT_STA_L_15, pData[0]);
2510   4                                      CScalerSetBit(_VGIP_CTRL_10, ~_BIT4 , _BIT4);
2511   4                              }
2512   3                      }
2513   2              }
2514   1      }
2515          //730702###
2516          //731301***
2517          //--------------------------------------------------
2518          // Description  : Enable HDMI watch dog
2519          // Input Value  : ucPar --> Parameter for HDMI watch dog
2520          // Output Value : None
2521          //--------------------------------------------------
2522          void CAdjustEnableHDMIWatchDog(BYTE ucPar)
2523          {
2524   1          CScalerPageSelect(_PAGE2);  //Issac-0129-Fixed
2525   1      
2526   1          if((ucPar & _WD_SET_AVMUTE_ENABLE) == 0x01)
2527   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~_BIT7, _BIT7); //Enable Set_AVMut
             -e Watch Dog
2528   1      
2529   1          if((ucPar & _WD_AUDIO_FOR_TMDS_CLOCK) == 0x02)
2530   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR1_32, ~_BIT7, _BIT7);//Enable Audio Watc
             -h Dog for TMDS clock
2531   1      
2532   1          if((ucPar & _WD_PACKET_VARIATION) == 0x04)
2533   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VWDSR_41, ~_BIT0, _BIT0);//Enable packet var
             -iation Watch Dog
2534   1      
2535   1          if((ucPar & _WD_AUDIO_FIFO) == 0x08)
2536   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~(_BIT2 | _BIT1), (_BIT2 | _BIT1))
             -; //Enable Audio Watch Dog
2537   1      }
2538          
2539          //--------------------------------------------------
2540          // Description  : Disable HDMI watch dog
2541          // Input Value  : ucPar --> Parameter for HDMI watch dog
2542          // Output Value : None
2543          //--------------------------------------------------
2544          void CAdjustDisableHDMIWatchDog(BYTE ucPar)
2545          {
2546   1          CScalerPageSelect(_PAGE2);  //Issac-0129-Fixed
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 43  

2547   1      
2548   1          if((ucPar & _WD_SET_AVMUTE_ENABLE) == 0x01)
2549   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~_BIT7, 0x00); //Disable Set_AVMut
             -e Watch Dog
2550   1      
2551   1          if((ucPar & _WD_AUDIO_FOR_TMDS_CLOCK) == 0x02)
2552   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR1_32, ~_BIT7, 0x00);//Disable Audio Watc
             -h Dog for TMDS clock
2553   1      
2554   1          if((ucPar & _WD_PACKET_VARIATION) == 0x04)
2555   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VWDSR_41, ~_BIT0, 0x00);//Disable packet var
             -iation Watch Dog
2556   1      
2557   1          if((ucPar & _WD_AUDIO_FIFO) == 0x08)
2558   1              CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_WDCR0_31, ~(_BIT2 | _BIT1), 0x00); //Disable
             - Audio Watch Dog
2559   1      }
2560          #endif
2561          //731301###
2562          
2563          
2564          //------------------------------------------------------------
2565          //                MCU DAC function
2566          //------------------------------------------------------------
2567          void CSetPWM(BYTE PWMId, WORD Value)
2568          {         
2569   1          BYTE ucPWMData = 0;
2570   1      
2571   1      /*
2572   1           switch(PWMId)
2573   1           {
2574   1               case _SCALAR_PWM0:             // Scalar PWM
2575   1               case _SCALAR_PWM1:
2576   1               case _SCALAR_PWM2:
2577   1                   pData[0] = PWMId << 6;     // PWM ID
2578   1                   pData[1] = 0x01;
2579   1                   pData[2] = Value;
2580   1                   CScalerWrite(_OSD_ADDR_MSB_90,3,pData,_AUTOINC);
2581   1                   break;
2582   1      
2583   1      #if(_MCU_TYPE == _MYSON_MTV512 || _MCU_TYPE == _RTD_2120)
2584   1               case _MCU_PWM0:
2585   1               case _MCU_PWM1:
2586   1               case _MCU_PWM2:
2587   1                    CSetMCUPWM(PWMId - _MCU_PWM0,Value);
2588   1                    break;
2589   1      
2590   1               case _MCU_PWM3:
2591   1               case _MCU_PWM4:
2592   1               case _MCU_PWM5:
2593   1                    CSetMCUPWM(PWMId - _MCU_PWM3,Value);
2594   1                    break;
2595   1      #endif
2596   1           }  */
2597   1           switch(PWMId)
2598   1           {
2599   2           case 0:  // PWM0
2600   2      /*         ucPWMData = MCU_PWM01L_DUT_FF4C;
2601   2               MCU_PWM0H_DUT_FF4A  = (Value >> 4) & 0xFF;
2602   2               MCU_PWM01L_DUT_FF4C = (ucPWMData & 0xF0) | ((BYTE)Value & 0x0F); */
2603   2               MCU_PWM0H_DUT_FF4A  = Value;
2604   2               break;
C51 COMPILER V9.00   ADJUST                                                                08/25/2023 16:47:31 PAGE 44  

2605   2      
2606   2           case 1:  // PWM1
2607   2      /*         ucPWMData = MCU_PWM01L_DUT_FF4C;
2608   2               MCU_PWM1H_DUT_FF4B  = (Value >> 4) & 0xFF;
2609   2               MCU_PWM01L_DUT_FF4C = (ucPWMData & 0x0F) | (((BYTE)Value & 0x0F) << 4); */
2610   2               MCU_PWM1H_DUT_FF4B  = Value;
2611   2               break;
2612   2      
2613   2           case 2:  // PWM2
2614   2      /*         ucPWMData = MCU_PWM23L_DUT_FF4F;
2615   2               MCU_PWM2H_DUT_FF4D  = (Value >> 4) & 0xFF;
2616   2               MCU_PWM23L_DUT_FF4F = (ucPWMData & 0xF0) | ((BYTE)Value & 0x0F);*/
2617   2               MCU_PWM2H_DUT_FF4D  = Value;
2618   2               break;
2619   2      
2620   2           case 3:  // PWM3
2621   2      /*         ucPWMData = MCU_PWM23L_DUT_FF4F;
2622   2               MCU_PWM3H_DUT_FF4E  = (Value >> 4) & 0xFF;
2623   2               MCU_PWM23L_DUT_FF4F = (ucPWMData & 0x0F) | (((BYTE)Value & 0x0F) << 4); */
2624   2               MCU_PWM3H_DUT_FF4E  = Value;
2625   2               break;
2626   2      
2627   2           case 4:  // PWM4
2628   2      /*         ucPWMData = MCU_PWM45L_DUT_FF52;
2629   2               MCU_PWM4H_DUT_FF50  = (Value >> 4) & 0xFF;
2630   2               MCU_PWM45L_DUT_FF52 = (ucPWMData & 0xF0) | ((BYTE)Value & 0x0F); */
2631   2               MCU_PWM4H_DUT_FF50  = Value;
2632   2               break;
2633   2      
2634   2           case 5:  // PWM5     
2635   2      /*         ucPWMData = MCU_PWM45L_DUT_FF52;
2636   2               MCU_PWM5H_DUT_FF51  = (Value >> 4) & 0xFF;
2637   2               MCU_PWM45L_DUT_FF52 = (ucPWMData & 0x0F) | (((BYTE)Value & 0x0F) << 4); */
2638   2               MCU_PWM5H_DUT_FF51  = Value;
2639   2               break;
2640   2      
2641   2           }
2642   1      }
2643          //-------------------------------------------------
2644          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8720    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =      1     167
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     15    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
