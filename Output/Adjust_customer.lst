C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADJUST_CUSTOMER
OBJECT MODULE PLACED IN .\Output\Adjust_customer.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil\C51\BIN\C51.EXE Core\code\Adjust_customer.c LARGE OPTIMIZE(9,SPEED) BRO
                    -WSE DEBUG OBJECTEXTEND PRINT(.\Output\Adjust_customer.lst) OBJECT(.\Output\Adjust_customer.obj)

line level    source

   1          /*===========================================================
   2           * Copyright (c)      Realtek Semiconductor Corporation, 2005
   3           * All rights reserved.
   4           * ========================================================== */
   5          
   6          /*==================== File Description ===================== */
   7          /**
   8           * @file
   9           *      This file is osd control declaration related functions.
  10           *
  11           * @author      $Author: forster $
  12           * @date        $Date: 2006-03-21 20:24:23 +0800 (??浜? 21 涓? 2006) $
  13           * @version     $Revision: 451 $
  14           * @ingroup Auto
  15           */
  16          
  17          /**
  18           * @addtogroup Auto
  19           * @{
  20           */
  21          
  22          #define _ADJUST_CUSTOMER_C
  23          /*===================== Module dependency  ================== */
  24          #include "Core\Header\Include.h"
  25          
  26          extern void MSharpAdjLR(BYTE LR);
  27          
  28          //--------------------------------------------------
  29          // Description  : Adjust sharpness
  30          // Input Value  : None
  31          // Output Value : None
  32          //--------------------------------------------------
  33          void fuck_you_made()
  34          {
  35   1      
  36   1          unsigned char xxData[47]={0,   250, 9,   250, 20, 250,  250, 20,  250, 250,
  37   1                                        20,  250, 250, 20,  250, 250, 250, 250, 250, 250,
  38   1                                                                250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
  39   1                                                                250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
  40   1                                                                250, 250, 250, 250, 250, 250, 250};
  41   1              
  42   1              CScalerPageSelect(_PAGE7);
  43   1              CScalerSetByte(_P7_AUTO_SHP_CTRL_B7,0x00);
  44   1          CScalerSetByte(_P7_AUTO_SHP_ADDR_B8, 0x00);
  45   1          CScalerWrite(_P7_AUTO_SHP_DATA_B9, 47, xxData, _NON_AUTOINC);
  46   1          CScalerSetByte(_P7_AUTO_SHP_ADDR_B8, 0x00); 
  47   1      }
  48          
  49          //--------------------------------------------------
  50          // Description  : Adjust color precessing brightness
  51          // Input Value  : None
  52          // Output Value : None
  53          //--------------------------------------------------
  54          void CAdjustBrightness(void)//亮度
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 2   

  55          {
  56   1              pData[0] =(0x65 + stConBriData.Brightness - 50);//0x65;//(0x80 + stConBriData.Brightness - 60);
  57   1              pData[1] =(0x63 + stConBriData.Brightness - 50);//0x63;// (0x80 + stConBriData.Brightness - 60);
  58   1              pData[2] =(0x63 + stConBriData.Brightness - 50);//0x63;// (0x80 + stConBriData.Brightness - 60);
  59   1              CAdjustSetBrightness();//pData[0-2]=0x76.0x76.0x76
  60   1          CAdjustBacklight();
  61   1      }
  62          
  63          //--------------------------------------------------
  64          // Description  : Adjust color processing contrast
  65          // Input Value  : None
  66          // Output Value : None
  67          //--------------------------------------------------
  68          void CAdjustContrast(void)//对比度
  69          {
  70   1              BYTE cnt;
  71   1      
  72   1          for(cnt=0;cnt<3;cnt++)
  73   1              {
  74   2                      //pData[cnt] = (((WORD)stColorTempData.ColorTemp[cnt] * stConBriData.Contrast / 128) > 255) ? 255 : (BYT
             -E)((WORD)stColorTempData.ColorTemp[cnt] * stConBriData.Contrast / 128);
  75   2              pData[cnt] = (BYTE)(((WORD)stColorTempData.ColorTemp[cnt] * (stConBriData.Contrast+_CONTRAST_MIN) / 1
             -28) > 255) ? 255 : (BYTE)((WORD)stColorTempData.ColorTemp[cnt] * (stConBriData.Contrast+_CONTRAST_MIN) / 128);
  76   2              }
  77   1      //      pData[0]=0x85;
  78   1      //      pData[1]=0x85;
  79   1      //      pData[2]=0x85;
  80   1      
  81   1              CAdjustSetContrast();//设置函数
  82   1      //      for(cnt=0;cnt<125;cnt++)CAdjustSharpnessForScaleUp();
  83   1      //      CAdjustYpbprhue(0xa0);
  84   1      }
  85          
  86          #if (sRGB_Color_Enhance == _ENABLE)
  87          void CAdjustYpbprhue(BYTE  ucYPbPrhue)
  88          {
  89   1              CAdjustSaturationHue(ucYPbPrhue, _FALSE);
  90   1      }
  91                       /*
  92          
  93          #define _YUV2RGB_k13   1
  94          #define _YUV2RGB_k22   2
  95          #define _YUV2RGB_k23   3
  96          #define _YUV2RGB_k32   4
  97          UINT16 tYUV2RGB_COEF_601_YCbCr[] =
  98          {
  99           
 100            0x0100, // k11
 101            0x0166, // k13
 102            0x0058, // k22
 103            0x00b6, // k23
 104            0x01c5, // k32
 105            0x0000, // R-offset
 106            0x0000, // G-offset
 107            0x0000, // B-offset
 108           
 109            0x0000, // Y Clamp (Y-16)
 110            0x0001, // UV Clamp (UV-512)
 111           
 112          };              */
 113          
 114          void CAdjustYpbprSaturation(BYTE  ucYPbPrSaturation)
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 3   

 115          {
 116   1              WORD PB,PR;//,new_k13,new_k22,new_k23,new_k32,new_coeffs;
 117   1              BYTE temp;
 118   1      
 119   1              temp=ucYPbPrSaturation;
 120   1          // EricLee add
 121   1              CScalerPageSelect(_PAGE7);
 122   1          if (ucYPbPrSaturation < 11)
 123   1          {
 124   2              PR = (WORD)ucYPbPrSaturation*102;
 125   2              CScalerSetByte(0xD8, (BYTE)(PR>>8) | _BIT6);
 126   2              CScalerSetByte(0xD9, (BYTE)PR);
 127   2          }
 128   1          else
 129   1              CScalerSetByte(0xD8, 0x00);
 130   1      
 131   1          if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
 132   1          {
 133   2              PR = (temp <= 50)  ? ((WORD)stYPbPrData.YPbPrGain[_RED] + ((50 - temp) << 2)) :
 134   2              ((WORD)stYPbPrData.YPbPrGain[_RED] - (temp - 50));
 135   2          
 136   2              PB = (temp <= 50)  ? ((WORD)stYPbPrData.YPbPrGain[_BLUE] + ((50 - temp) << 2)) :
 137   2              ((WORD)stYPbPrData.YPbPrGain[_BLUE] - (temp - 50));
 138   2          
 139   2              if(HIBYTE(PB)>0)
 140   2                      PB  = HIBYTE(PB) < 0x02 ? 0x00FF : 0 ;
 141   2              if (HIBYTE(PR)>0)
 142   2                      PR  = HIBYTE(PR) < 0x02 ? 0x00FF : 0 ;
 143   2          
 144   2          #if(_ADC1_INPUT_SWAP_RG == _ON)
                  
                      pData[1] = PR;
                      pData[0] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = PB;
                  
                  #elif(_ADC1_INPUT_SWAP_RB == _ON)
                  
                      pData[2] = PR;
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[0] = PB;
                  
                  #elif(_ADC1_INPUT_SWAP_GB == _ON)
 157   2          
 158   2              pData[0] = PR;
 159   2              pData[2] = stYPbPrData.YPbPrGain[_GREEN];
 160   2              pData[1] = PB;
 161   2          
 162   2          #else
                  
                      pData[0] = PR;
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = PB;
                  
                  #endif
 169   2              //CAdjustSetYpbprSaturation();//eric 20070613
 170   2              CAdjustSaturationHue(ucYPbPrSaturation, _TRUE);
 171   2          }
 172   1      
 173   1              //Lewis, adjust sRGB domain
 174   1              CAdjustSaturationHue(ucYPbPrSaturation, _TRUE);
 175   1                        /*
 176   1      
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 4   

 177   1          new_coeffs =  (double)  tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k13] * ucYPbPrSaturation;
 178   1          new_coeffs = (new_coeffs >> 7) ;
 179   1          new_k13 = (new_coeffs > 0x1ff) ? 0x1ff: new_coeffs;
 180   1          
 181   1          new_coeffs = (double)  tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k22]  * ucYPbPrSaturation;
 182   1          new_coeffs = (new_coeffs >> 7) ;
 183   1          
 184   1          new_k22 = (new_coeffs > 0xff) ? 0xff: new_coeffs;
 185   1          
 186   1          new_coeffs = (double)   tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k23]  * ucYPbPrSaturation;
 187   1          new_coeffs = (new_coeffs >> 7) ;
 188   1          
 189   1          new_k23 = (new_coeffs > 0xff) ? 0xff: new_coeffs;
 190   1          
 191   1          new_coeffs = (double)   tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k32]  * ucYPbPrSaturation;
 192   1          new_coeffs = (new_coeffs >> 7) ;
 193   1          
 194   1          new_k32 = (new_coeffs > 0x3ff) ? 0x3ff: new_coeffs;
 195   1      
 196   1      
 197   1              CScalerPageSelect(_PAGE7);
 198   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k13 >> 8));
 199   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k13 & 0xFF));
 200   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k22 >> 8));
 201   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k22 & 0xFF));
 202   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k23 >> 8));
 203   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k23 & 0xFF));
 204   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k32 >> 8));
 205   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k32 & 0xFF)); */
 206   1      }
 207          
 208          #else
              // cftsai 20061031 modify
              INT16 code RR[]=
              {
              -155,-149,-143,-138,-132,-127,-121,-116,-111,-105,
              -100, -95, -90, -85, -80, -75, -71, -66, -62, -57,
               -53, -49, -45, -40, -36, -33, -29, -25, -22, -18,
               -15, -12,  -8,  -5,  -2,   0,   2,   5,   7,  10,
                12,  14,  16,  18,  20,  22,  24,  25,  26,  28,
                29,  30,  31,  32,  32,  33,  33,  34,  34,  34,
                34,  34,  34,  33,  33,  32,  32,  31,  30,  29,
                28
              };
              
              INT16 code RG[]=
              {
              -100, -99, -98, -96, -95, -93, -92, -90, -88, -86,
               -84, -81, -79, -77, -74, -72, -69, -66, -63, -60,
               -57, -54, -51, -47, -44, -40, -36, -33, -29, -25,
               -21, -17, -13,  -8,  -4,   0,   4,   9,  13,  18,
                23,  28,  33,  38,  43,  48,  53,  58,  64,  69,
                74,  80,  86,  91,  97, 102, 108, 114, 120, 126,
               132, 138, 144, 150, 156, 162, 168, 174, 180, 186,
               193
              };
              
              INT16 code RB[]=
              {
              255, 249, 242, 235, 227, 220, 213, 206, 199, 192,
              184, 177, 170, 162, 155, 148, 140, 133, 125, 118,
              110, 103,  96,  88,  81,  73,  66,  58,  51,  44,
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 5   

               36,  29,  21,  14,   7,   0,  -7, -14, -21, -28,
              -35, -42, -49, -56, -63, -70, -77, -84, -91, -97,
              -104, -110, -117, -123, -130, -136, -142, -148, -154, -160,
              -166, -172, -178, -184, -189, -195, -200, -205, -211, -216,
              -221
              };
              
              INT16 code GR[]=
              {
              162 ,157 ,152 ,147 ,142 ,137 ,132 ,127 ,
              122 ,117 ,113 ,108 ,103 ,98  ,93  ,88  ,
              84  ,79  ,74  ,70  ,65  ,60  ,56  ,51  ,
              47  ,42  ,38  ,33  ,29  ,25  ,20  ,16  ,
              12  ,8   ,4   ,0   ,-4  ,-7  ,-11 ,-15 ,
              -19 ,-23 ,-27 ,-30 ,-34 ,-37 ,-41 ,-44 ,
              -48 ,-51 ,-54 ,-57 ,-60 ,-63 ,-66 ,-69 ,
              -72 ,-75 ,-77 ,-80 ,-83 ,-85 ,-87 ,-90 ,
              -92 ,-94 ,-96 ,-98 ,-100,-102,-104
              };
              
              INT16 code GG[]=
              {
              -9 ,-7 ,-6 ,-4 ,-3 ,-2 ,-1 ,0  ,
              1  ,2  ,3  ,3  ,4  ,5  ,5  ,6  ,
              6  ,7  ,7  ,7  ,7  ,7  ,7  ,7  ,
              7  ,7  ,6  ,6  ,5  ,5  ,4  ,3  ,
              2  ,2  ,1  ,0  ,-1 ,-2 ,-3 ,-5 ,
              -6 ,-8 ,-9 ,-11,-13,-15,-16,-18,
              -20,-23,-25,-27,-29,-32,-34,-37,
              -39,-42,-45,-48,-51,-53,-56,-60,
              -63,-66,-69,-72,-76,-79,-83
              };
              
              INT16 code GB[]=
              {
              -152,-149,-145,-142,-138,-135,-131,-127,
              -123,-120,-116,-112,-108,-103,-99 ,-95 ,
              -91 ,-86 ,-82 ,-77 ,-73 ,-68 ,-64 ,-59 ,
              -54 ,-49 ,-45 ,-40 ,-35 ,-30 ,-25 ,-20 ,
              -15 ,-10 ,-5  ,0   ,5   ,10  ,15  ,20  ,
              26  ,31  ,36  ,42  ,47  ,52  ,58  ,63  ,
              69  ,74  ,79  ,85  ,90  ,96  ,101 ,107 ,
              112 ,117 ,123 ,128 ,134 ,139 ,144 ,150 ,
              155 ,160 ,166 ,171 ,176 ,181 ,187
              };
              
              INT16 code BR[]=
              {
              -172, -169, -165, -162 , -158, -154, -150, -146, -142, -138,
              -133, -129, -124,-120,-115,-110,-105,-100,-95,-90,
              -85,-80,-75,-69,-64,-58,-53,-47,-41,-35,
              -30,-24,-18,-12,-6,0,6,12,18,24,
              31,37,44,50,57,63,70,76,83,89,
              96,103,109,116,123,130,136,143,150,157,
              163,170,177,183,190,197,204,210,217,224,
              230
              };
              
              INT16 code BG[]=
              {
              193 ,186 ,180 ,174 ,168 ,162 ,156 ,150 ,
              144 ,138 ,132 ,126 ,120 ,114 ,108 ,102 ,
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 6   

              97  ,91  ,86  ,80  ,74  ,69  ,64  ,58  ,
              53  ,48  ,43  ,38  ,33  ,28  ,23  ,18  ,
              13  ,9   ,4   ,0   ,-4  ,-8  ,-13 ,-17 ,
              -21 ,-25 ,-29 ,-33 ,-36 ,-40 ,-44 ,-47 ,
              -51 ,-54 ,-57 ,-60 ,-63 ,-66 ,-69 ,-72 ,
              -74 ,-77 ,-79 ,-81 ,-84 ,-86 ,-88 ,-90 ,
              -92 ,-93 ,-95 ,-96 ,-98 ,-99 ,-100
              };
              
              INT16 code BB[]=
              {
              -20 ,-17, -14, -12, -9, -7, -5, -3,
              -1  ,0   ,1   ,3   ,4   ,5   ,6   ,7   ,
              8   ,9   ,9   ,10  ,10  ,10  ,10  ,10  ,
              10  ,10  ,9   ,9   ,8   ,7   ,6   ,5   ,
              4   ,3   ,1   ,0   ,-1  ,-3  ,-5  ,-7  ,
              -9  ,-12 ,-14 ,-17 ,-20 ,-22 ,-25 ,-29 ,
              -32 ,-35 ,-39 ,-42 ,-46 ,-50 ,-53 ,-57 ,
              -62 ,-66 ,-70 ,-75 ,-79 ,-84 ,-88 ,-93 ,
              -98 ,-103,-108,-114,-119,-124,-130
              };
              
              void CAdjustYpbprhue(BYTE  ucYPbPrhue)
              {
                      BYTE uchue ;
              
                      uchue = ucYPbPrhue *0.7 ;
                      //Write R
                      pData[0] = ((RR[uchue] >> 8) & 0x01);   // RRH
                      pData[1] = (RR[uchue] & 0xff);          // RRL
                      pData[2] = ((RG[uchue] >> 8) & 0x01);   // RGH
                      pData[3] = (RG[uchue] & 0xff);          // RGL
                      pData[4] = ((RB[uchue] >> 8) & 0x01);   // RBH
                      pData[5] = (RB[uchue] & 0xff);          // RBL
                      CAdjustSetYpbprRhue();
              
                      //Write G
                      pData[0] = ((GR[uchue] >> 8) & 0x01);   // GRH
                      pData[1] = (GR[uchue] & 0xff);          // GRL
                      pData[2] = ((GG[uchue] >> 8) & 0x01);   // GGH
                      pData[3] = (GG[uchue] & 0xff);          // GGL
                      pData[4] = ((GB[uchue] >> 8) & 0x01);   // GBH
                      pData[5] = (GB[uchue] & 0xff);          // GBL
                      CAdjustSetYpbprGhue();
              
                      //Write B
                      pData[0] = ((BR[uchue] >> 8) & 0x01);   // BRH
                      pData[1] = (BR[uchue] & 0xff);          // BRL
                      pData[2] = ((BG[uchue] >> 8) & 0x01);   // BGH
                      pData[3] = (BG[uchue] & 0xff);          // BGL
                      pData[4] = ((BB[uchue] >> 8) & 0x01);   // BBH
                      pData[5] = (BB[uchue] & 0xff);          // BBL
                      CAdjustSetYpbprBhue();
              
                      CScalerSetBit(_COLOR_CTRL_62, 0xff, 0x80);                      // cftsai 20061031 added, ready to write
              }
              
              
              void CAdjustYpbprSaturation(BYTE  ucYPbPrSaturation)
              {
                  WORD    PB, PR ;
              
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 7   

                      PR = (WORD)stYPbPrData.YPbPrGain[_RED] * (100 - ucYPbPrSaturation) /(WORD)50  ;
                      PB = (WORD)stYPbPrData.YPbPrGain[_BLUE] * (100 - ucYPbPrSaturation) /(WORD)50 ;
              if(HIBYTE(PB)>0)
                      PB  = 0x00FF ;
              if (HIBYTE(PR)>0)
                      PR  = 0x00FF ;
              
               #if(_ADC_INPUT_SWAP_RG == _ON)
              
                  pData[1] = PR;
                  pData[0] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[2] = PB;
              
              #elif(_ADC_INPUT_SWAP_RB == _ON)
              
                  pData[2] = PR;
                  pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[0] = PB;
              
              #elif(_ADC_INPUT_SWAP_GB == _ON)
              
                  pData[0] = PR;
                  pData[2] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[1] = PB;
              
              #else
              
                  pData[0] = PR;
                  pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[2] = PB;
              
              #endif
                      CAdjustSetYpbprSaturation();
              
              }
              #endif          // sRGB_Color_Enhance end
 399          
 400          
 401          
 402          #if(_AdjustCustomerColorMode==_ENABLE)
              void CAdjustCustomerColorMode(void)
              {
              #if(_COLOR_PREFERENCE == _PANASONIC_STYLE)
              
              // Brightness_R,Brightness_G,Brightness_B,Contrast_R,Contrast_G,Contrast_B,Sharpness_Num
              // VDC_Contrast,VDC_Brightness,VDC_Saturation,VDC_Hue,VDC_Shaprness
              
                      BYTE code ColorType[][12] = {
                      // CVBS,SV
                      //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                              0x80,  0x80,  0x7F,  0x87,  0x80,  0x7A,   6,        38,           0x78,     64,         46,          0x
             -17,
              
                      // TV
                      //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                              0x80,  0x80,  0x80,  0x80,  0x80,  0x80,  6,        52,           0x85,     52,         47,          0x1
             -7,
                         //0x80,  0x80,  0x80,  0x80,  0x80,  0x80,   6,        33,           0x85,     58,         46,        
             -  0x17,
              
                      // YPbPr  , HDMI
                      //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 8   

                              0x80,  0x80,  0x7F,  0xB3,  0xAA,  0xA2,   6,        38,           0x78,     50,         50,          0x
             -17,
                         //0x80,  0x80,  0x7F,  0xB3,  0xAA,  0xA2,   6,        38,           0x78,     50,         50,        
             -  0x17,
              
              
                      };
              
                      if(!bSourceVideo())
                      {
              
                                      pData[0] = ColorType[2][0];
                                      pData[1] = ColorType[2][1];
                                      pData[2] = ColorType[2][2];
                                      pData[3] = ColorType[2][3];
                                      pData[4] = ColorType[2][4];
                                      pData[5] = ColorType[2][5];
              
                                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                              CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
                                      SET_PEAKING_CORING(ColorType[2][6]);
                                      SET_CONTRAST(ColorType[2][7]);
                                      //SET_YPbPrSaturation(ColorType[2][9]);
                                      //SET_YPbPrHue(ColorType[2][10]);
                                   SET_SATURATION(ColorType[2][9]);
                                      SET_HUE(ColorType[2][10]);                      
                                      CEepromSaveSystemData();
              
                                      CAdjustPeakingFilter(GET_PEAKING_CORING());
                                      CAdjustContrast();
                                      //CAdjustYpbprSaturation(GET_YPbPrSaturation());
                                      //CAdjustYpbprhue(GET_YPbPrHue());
                                      CAdjustYpbprSaturation(GET_SATURATION());
                                      CAdjustYpbprhue(50);//GET_HUE());
                                      CScalerSetBit(_COLOR_CTRL_62, 0xFF, _BIT2);
              
                      }
                      else
                      {       
                              if(_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV)
                              {
                                      
                                      pData[0] = ColorType[1][0];
                                      pData[1] = ColorType[1][1];
                                      pData[2] = ColorType[1][2];
                                      pData[3] = ColorType[1][3];
                                      pData[4] = ColorType[1][4];
                                      pData[5] = ColorType[1][5];
              
                                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                                      CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
              
                                      SET_PEAKING_CORING(ColorType[1][6]);
                                      SET_CONTRAST(ColorType[1][7]);
                                      SET_SATURATION(ColorType[1][9]);
                                      SET_HUE(ColorType[1][10]);
                                      CVideoSetVDCBrightness(ColorType[1][8]);
                                      I2CByteWrite(0x80,_VIDEO_DEVICE,ColorType[1][11]);
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 9   

                                      
                                      CEepromSaveSystemData();
                              }
                              else
                              {
                              
                              
                                      pData[0] = ColorType[0][0];
                                      pData[1] = ColorType[0][1];
                                      pData[2] = ColorType[0][2];
                                      pData[3] = ColorType[0][3];
                                      pData[4] = ColorType[0][4];
                                      pData[5] = ColorType[0][5];
              
                                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                                      CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                                      CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
                                      SET_PEAKING_CORING(ColorType[0][6]);
                                      SET_CONTRAST(ColorType[0][7]);
                                      SET_SATURATION(ColorType[0][9]);
                                      SET_HUE(ColorType[0][10]);
                                      CVideoSetVDCBrightness(ColorType[0][8]);
                                  I2CByteWrite(0x80,_VIDEO_DEVICE,ColorType[0][11]);
                                      
                                      CEepromSaveSystemData();
              
                              }
                              CAdjustPeakingFilter(GET_PEAKING_CORING());
                              CVideoSetContrast(GET_CONTRAST());
                              CVideoSetSaturation(GET_SATURATION());
                              gmi_CAdjustVDCHue(GET_HUE());           
                      }
              
              
              #endif
              
              
              #if(sRGB_Color_Enhance == _ENABLE)
              
                      CVideoSetSaturation(GET_SATURATION());
                      gmi_CAdjustVDCHue(GET_HUE());
                      CScalerSetBit(_COLOR_CTRL_62, ~_BIT2, _BIT2);           // enable sRGB
              
              #endif
              
              }
              #endif
 530          
 531          
 532          #if(_VIDEO_AUTO_WHITE_BLANCE == _ENABLE)
 533          #define _VIDEO_SATURATION_MAX   0xFF
 534          #define _VIDEO_SATURATION_MIN   0x00
 535          #endif
 536          
 537          //--------------------------------------------------
 538          // Description  : Set  2610 Saturation
 539          // Input Value  : saturationNone
 540          // Output Value : None
 541          //--------------------------------------------------
 542           void CVideoSetSaturation(BYTE ucValue)
 543          {
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 10  

 544   1      #if(_VIDEO_AUTO_WHITE_BLANCE == _ENABLE)
 545   1              BYTE ucSaturation;
 546   1              BYTE temp;
 547   1      
 548   1              ucSaturation = 140;//GET_VDC_CHROMA();
 549   1              if(ucValue > 50)
 550   1          {
 551   2                      temp = ((UINT16)((_VIDEO_SATURATION_MAX - ucSaturation)*(ucValue - 50))) / 50;
 552   2                      temp += ucSaturation;
 553   2              }
 554   1              else if(ucValue < 50)
 555   1          {
 556   2                      temp = ((UINT16)((ucSaturation -_VIDEO_SATURATION_MIN) * (50 - ucValue))) / 50;
 557   2                      temp = ucSaturation - temp;
 558   2              }
 559   1              else
 560   1                      temp = ucSaturation;
 561   1              CVideoSetVDCSaturation(temp);
 562   1      #else
                      ucValue = ucValue * 2.5;
                      CVideoSetVDCSaturation(ucValue);
              #endif
 566   1      }
 567          
 568          //--------------------------------------------------
 569          // Description  : Set  2610 Contrast
 570          // Input Value  : ucValue
 571          // Output Value : None
 572          //--------------------------------------------------
 573          void CVideoSetContrast(BYTE ucValue)
 574          {
 575   1              ucValue = ucValue * 2.5;
 576   1          CVideoSetVDCContrast(ucValue);
 577   1      }
 578          
 579          void CAdjustHueSatSet(BYTE color, SWORD TempU1, SWORD TempU2, SWORD TempV1, SWORD TempV2)
 580          {
 581   1          BYTE i;
 582   1          SWORD u,v;
 583   1      
 584   1          BYTE value = (color & 0x0f);
 585   1              //CTimerWaitForEvent(_EVENT_DEN_STOP);
 586   1              CScalerPageSelect(_PAGE7);
 587   1      
 588   1          CScalerSetByte(_P7_ICM_SEL_D1, value);
 589   1          CScalerSetByte(_P7_ICM_ACCESS_PORT_D2,0x00);
 590   1          if(value == 0)
 591   1          {           //R
 592   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x02);
 593   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xd2);
 594   2                      if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 595   2                      CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xaa);
 596   2                      else
 597   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xee);
 598   2          }
 599   1              else if(value == 1)
 600   1          {//G
 601   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x08);
 602   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x00);
 603   2                      if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 604   2                      CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 605   2                      else
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 11  

 606   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xee);
 607   2          }
 608   1          else if(value == 2)
 609   1          {//B
 610   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x0d);
 611   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x2e);
 612   2                      if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 613   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 614   2              else
 615   2                              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xbe);
 616   2          }
 617   1          else if(value == 3)
 618   1          {//Y
 619   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x05);
 620   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x2e);
 621   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x62);  //ff
 622   2          }
 623   1          else if(value == 4)
 624   1          {//C
 625   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x0a);
 626   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xd2);
 627   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 628   2          }
 629   1          //CTimerWaitForEvent(_EVENT_DEN_STOP);
 630   1          CScalerSetByte(_P7_ICM_SEL_D1,value);
 631   1          CScalerSetByte(_P7_ICM_ACCESS_PORT_D2,((color & 0xf0)+0x03));
 632   1              //CScalerSendAddr(_P7_ICM_DATA_PORT_D3, _WRITE, _NON_AUTOINC);//provisional 既w
 633   1              
 634   1          for(i=1; i<9; i++)
 635   1          {
 636   2                      u = ((TempU1+TempU2)*CAdjustColorGammaCal(value, i)/64) - ((TempU1*i)/8);
 637   2                      v = ((TempV1+TempV2)*CAdjustColorGammaCal(value, i)/64) - ((TempV1*i)/8);
 638   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,u); //CScalerSetByte(0xe3,u);               
 639   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,v); //CScalerSetByte(0xe3,v);               
 640   2          }
 641   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA || _GET_INPUT_SOURCE() == _SOURCE_DVI)//CGetInputSourceNum(_GET_IN
             -PUT_SOURCE())>1)
 642   1                      CScalerSetByte(_P7_ICM_CTRL_D0,0xdf);
 643   1              else
 644   1                      CScalerSetByte(_P7_ICM_CTRL_D0,0xdc);
 645   1              
 646   1      }
 647          
 648          #define CENTER    0x00
 649          #define RIGHT     0x10
 650          #define LEFT      0x20
 651          void CAdjustSetHueUVDelta(BYTE color, BYTE select)
 652          {
 653   1          SWORD TempU1,TempV1,TempU2,TempV2;
 654   1      
 655   1              pData[0] = (select >> 3); //(select >> 4) << 1
 656   1              pData[1] = pData[0] + 1;
 657   1      
 658   1              if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 659   1              {
 660   2                TempU1 = Video_TempUV1[color][pData[0]];
 661   2                TempV1 = Video_TempUV1[color][pData[1]];
 662   2              }
 663   1              else
 664   1              {
 665   2                TempU1 = Graphic_TempUV1[color][pData[0]];
 666   2                TempV1 = Graphic_TempUV1[color][pData[1]];
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 12  

 667   2              }
 668   1      
 669   1              pData[2] = color*3 + (select >> 4);
 670   1      
 671   1              if(stICMColor.ICM_COLOR[color] < 8)
 672   1              {
 673   2                 TempU2 = (long)TempUV2[pData[2]][0] * (8 - stICMColor.ICM_COLOR[color]) >> 3;
 674   2                 TempV2 = (long)TempUV2[pData[2]][1] * (8 - stICMColor.ICM_COLOR[color]) >> 3;
 675   2              }
 676   1              else
 677   1              {
 678   2                 TempU2 = (long)TempUV2[pData[2]][2] * (stICMColor.ICM_COLOR[color] - 8) >> 3;
 679   2                 TempV2 = (long)TempUV2[pData[2]][3] * (stICMColor.ICM_COLOR[color] - 8) >> 3;
 680   2              }
 681   1              CAdjustHueSatSet((select | color), TempU1, TempU2, TempV1, TempV2);
 682   1      
 683   1      
 684   1      }
 685          #if(_COLOR_PREFERENCE == _PANASONIC_STYLE)
 686          
 687          #define RF_StartOffset          5
 688          #define AV_StartOffset          0
 689          #define YPbPr_StartOffset       0
 690          
 691          // 0xFF -1   0xFE -2
 692          void CAdjustPeakingFilter(SBYTE ucPeaking)
 693          {
 694   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA )//|| _GET_INPUT_SOURCE() == _SOURCE_HDMI)
 695   1          {
 696   2                      CScalerPageSelect(_PAGE7);
 697   2                      CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, 0x00);     // disable Peaking and Coring
 698   2              CScalerSetBit(_P7_DLTI_DCTI_ENABLE_A1, ~(_BIT6 | _BIT7), 0x00);
 699   2                      CScalerPageSelect(_PAGE6);
 700   2              CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x4A);
 701   2              CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x00);
 702   2                      return;
 703   2              }
 704   1              else if(0)//(_GET_INPUT_SOURCE() == _SOURCE_DVI || _GET_INPUT_SOURCE() == _SOURCE_HDMI)
 705   1          {
 706   2                      //if(HDMI_V_Height>=720)                //720p above
 707   2                              pData[0] = 0x00;                                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 708   2                      //else
 709   2                              //pData[0] = 0x00;                                      //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 710   2                      pData[1] = 0x7E;                                                //Peaking_C0 (126) 
 711   2                      pData[2] = 0xF7;                                                //Peaking_C1 (-19)      
 712   2                      pData[3] = 0x4A;                                                //Peaking_C2 (82)
 713   2                      pData[4] = 0x00;                                                //Gain_Blur
 714   2                      pData[5] = (WORD)(ucPeaking*195)/100;           //Gain_Pos(Min~Max)
 715   2                      pData[6] = (WORD)(ucPeaking*195)/100;           //Gain_Neg(Min~Max)
 716   2                      pData[7] = 0x0F;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 717   2                      pData[8] = 0xFF;                                                //Pos_Range(LSB)(1023)
 718   2                      pData[9] = 0xFF;                                                //Neg_Range(LSB)(1023)
 719   2                      pData[10] = 0x09;                                       //Coring(LV_min~LV_max)         
 720   2              }               
 721   1              else if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
 722   1          {
 723   2                      //if(HDMI_V_Height>=720)                //720p above
 724   2                              pData[0] = 0x00;                                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 725   2                      //else
 726   2                              //pData[0] = 0x00;                                      //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 727   2                      pData[1] = 0x7E;                                                //Peaking_C0 (126) 
 728   2                      pData[2] = 0xF7;                                                //Peaking_C1 (-19)      
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 13  

 729   2                      pData[3] = 0x4A;                                                //Peaking_C2 (82)
 730   2                      pData[4] = 0x00;                                                //Gain_Blur
 731   2                      pData[5] = (WORD)(ucPeaking*195)/100;           //Gain_Pos(Min~Max)
 732   2                      pData[6] = (WORD)(ucPeaking*195)/100;           //Gain_Neg(Min~Max)
 733   2                      pData[7] = 0x00;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 734   2                      pData[8] = 0x20;                                                //Pos_Range(LSB)(1023)
 735   2                      pData[9] = 0x40;                                                //Neg_Range(LSB)(1023)
 736   2                      pData[10] = 0x0E;                                       //Coring(LV_min~LV_max)                 
 737   2              }       
 738   1              else
 739   1          {//AV SV TV
 740   2                      pData[0] = 0x00;                                            //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels                     
 741   2                      pData[1] = 0x7E;                                                //Peaking_C0  
 742   2                      pData[2] = 0x0B;                                                //Peaking_C1    
 743   2                      pData[3] = 0x36;                                                //Peaking_C2 
 744   2                      pData[4] = 0x00;                                                //Gain_Blur
 745   2                      pData[5] = (WORD)(ucPeaking*255)/100;   //Gain_Pos(Min~Max)
 746   2                      pData[6] = (WORD)(ucPeaking*255)/100;   //Gain_Neg(Min~Max)
 747   2                      pData[7] = 0x00;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 748   2                      pData[8] = 0x08;                                                //Pos_Range(LSB)(1023)
 749   2                      pData[9] = 0x80;                                                //Neg_Range(LSB)(1023)
 750   2                      pData[10] = 0x05;                                           //Coring(LV_min~LV_max)
 751   2              }       
 752   1                      
 753   1          // D-Domain Peaking 
 754   1              CScalerPageSelect(_PAGE7);
 755   1              CScalerWrite(_P7_PEAKING_DATA00_AA, 11, pData, _AUTOINC);
 756   1      #if(_HDMI_SUPPORT == _OFF)
                      if(_GET_INPUT_SOURCE()==_SOURCE_DVI)//HDMI Source & input DVI timing
              #elif(_HDMI_SUPPORT == _ON || _TMDS_SUPPORT == _ON)
 759   1              if(0)//(_GET_INPUT_SOURCE()==_SOURCE_DVI || (_GET_INPUT_SOURCE() == _SOURCE_HDMI && !CHdmiFormatDetect())
             -)//HDMI Source & input DVI timing
 760   1                      CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, 0x00);             // disable Peaking and Coring
 761   1              else
 762   1      #endif
 763   1          {
 764   2              if (bSourceVideo())
 765   2              {
 766   3                      CScalerSetByte(_P7_DLTI_DCTI_ENABLE_A1, 0xC0);       //Open  D DOMAIN's DCTI, Open GAIN to 0xOF
 767   3                      CScalerSetByte(_P7_DLTI_GAIN_A3, 0x05);              //DLTi_Gain
 768   3                      CScalerSetByte(_P7_DLTI_GAIN_THRESHOLD_A4, 0x01);        //DLTi_Gain_Threshold   0x1e
 769   3                      CScalerSetByte(_P7_DLTI_OPTIONS_A5, 0x70);               //DLTi_Options
 770   3                      CScalerSetByte(_P7_DCTI_1ST_GAIN_A6, 0x0F);              //Open GAIN to 0xOF
 771   3                  CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, _BIT3);        // enable Peaking and Coring
 772   3              }
 773   2              else
 774   2              {
 775   3                  CScalerSetBit(_P7_DLTI_DCTI_ENABLE_A1, ~(_BIT6 | _BIT7), 0x00);
 776   3                  CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, _BIT3);        // enable Peaking and Coring
 777   3              }
 778   2          }
 779   1      
 780   1          switch(_GET_INPUT_SOURCE())
 781   1          {
 782   2          case _SOURCE_VGA:
 783   2                      CScalerPageSelect(_PAGE6);
 784   2                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, 0x00);     // disable Peaking and Coring
 785   2                      return;
 786   2      
 787   2          case _SOURCE_HDMI:
 788   2          case _SOURCE_DVI:
 789   2                      //if(HDMI_V_Height>=720)                //720p above
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 14  

 790   2                              pData[0] = 0x00;                                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 791   2                      //else
 792   2                              //pData[0] = 0x00;                                      //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 793   2                      pData[1] = 0x7E;                                                //Peaking_C0 (126) 
 794   2                      pData[2] = 0xF7;                                                //Peaking_C1 (-19)      
 795   2                      pData[3] = 0x4A;                                                //Peaking_C2 (82)
 796   2                      pData[4] = 0x00;                                                //Gain_Blur
 797   2                      pData[5] = 0x14/*ucPeaking*13*/;                //Gain_Pos(Min~Max)
 798   2                      pData[6] = 0x14/*ucPeaking*13*/;                //Gain_Neg(Min~Max)
 799   2                      pData[7] = 0x0F;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 800   2                      pData[8] = 0xFF;                                                //Pos_Range(LSB)(80)
 801   2                      pData[9] = 0xFF;                                                //Neg_Range(LSB)(80)
 802   2                      pData[10] = 0x09;                                       //Coring(LV_min~LV_max)         
 803   2              break;
 804   2      
 805   2          case _SOURCE_YPBPR:
 806   2                      pData[0] = 0x00;                                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels                   
 807   2                      pData[1] = 0x7E;                                                //Peaking_C0 (126) 
 808   2                      pData[2] = 0xF7;                                                //Peaking_C1 (-19)      
 809   2                      pData[3] = 0x4A;                                                //Peaking_C2 (82)
 810   2                      pData[4] = 0x00;                                                //Gain_Blur
 811   2                      pData[5] = 0x14/*ucPeaking*13*/;                //Gain_Pos(Min~Max)
 812   2                      pData[6] = 0x14/*ucPeaking*13*/;                //Gain_Neg(Min~Max)
 813   2                      pData[7] = 0x0F;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 814   2                      pData[8] = 0xFF;                                                //Pos_Range(LSB)(1023)
 815   2                      pData[9] = 0xFF;                                                //Neg_Range(LSB)(1023)
 816   2                      pData[10] = 0x09;                                       //Coring(LV_min~LV_max)                 
 817   2              break;
 818   2      
 819   2          default:   //AV TV SV               
 820   2                      pData[0] = 0x00;                                            //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels                    
 821   2                      pData[1] = 0x7F;                                                //Peaking_C0 
 822   2                      pData[2] = 0x4A;                                                //Peaking_C1    
 823   2                      pData[3] = 0xF6;                                                //Peaking_C2
 824   2                      pData[4] = 0x00;                                                //Gain_Blur
 825   2                      pData[5] = (WORD)(ucPeaking*255)/100;   //Gain_Pos(Min~Max)
 826   2                      pData[6] = (WORD)(ucPeaking*255)/100;   //Gain_Neg(Min~Max)
 827   2                      pData[7] = 0x00;                                                //Pos_Range(MSB)+Neg_Range(MSB)
 828   2                      pData[8] = 0x0A;                                                //Pos_Range(LSB)(1023)
 829   2                      pData[9] = 0x0A;                                                //Neg_Range(LSB)(1023)
 830   2                      pData[10] = 0x07;                                           //Coring(LV_min~LV_max)
 831   2              break;
 832   2              }
 833   1      
 834   1          // I-Domain Peaking 
 835   1              CScalerPageSelect(_PAGE6);
 836   1              CScalerWrite(_P6_PEAKING_DATA00_C2, 11, pData, _AUTOINC);
 837   1      #if(_HDMI_SUPPORT == _OFF)
                      if(_GET_INPUT_SOURCE()==_SOURCE_DVI)//HDMI Source & input DVI timing
              #elif(_HDMI_SUPPORT == _ON || _TMDS_SUPPORT == _ON)
 840   1              if(0)//_GET_INPUT_SOURCE()==_SOURCE_DVI || (_GET_INPUT_SOURCE() == _SOURCE_HDMI && !CHdmiFormatDetect()))
             -//HDMI Source & input DVI timing
 841   1                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, 0x00);             // disable Peaking and Coring
 842   1              else
 843   1      #endif
 844   1          {
 845   2              if (bSourceVideo())
 846   2              {
 847   3                  CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x0f);  //Close  I DOMAIN's DCTI,Open GAIN to 0xOF
 848   3                  CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x02);
 849   3                      CScalerSetByte(_P6_PEAKING_ENABLE_C1, 0x00);                // disable Peaking and Coring
 850   3              }
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 15  

 851   2              else
 852   2              {
 853   3                  CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x4A);
 854   3                  CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x00);
 855   3                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, _BIT3);    // enable Peaking and Coring
 856   3              }
 857   2              }
 858   1      }
 859                  
 860          #else
              
              #if(_Peaking_Coring_Table == SharpnessTable1)
                                                                                                                  
              BYTE code PeakingCoeff[][6] =
              {
                              //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                              //level=1 :
                              0x30, 0xe5, 0x3, 0x5, 0x50, 0xb0,
                              //level=2 :
                              0x38, 0xe1, 0x3, 0x5, 0x50, 0xb0,
                              //level=3 :
                              0x40, 0xdc, 0x4, 0x5, 0x50, 0xb0,
                              //level=4 :
                              0x46, 0xd7, 0x6, 0x5, 0x50, 0xb0,
                              //level=5 :
                              0x4e, 0xd3, 0x6, 0x5, 0x50, 0xb0,
                              //level=6 :
                              0x56, 0xce, 0x7, 0x5, 0x50, 0xb0,
                              //level=7 :
                              0x5e, 0xca, 0x7, 0x5, 0x50, 0xb0,
                              //level=8 :
                              0x66, 0xc5, 0x8, 0x5, 0x50, 0xb0,
                              //level=9 :
                              0x6e, 0xc1, 0x8, 0x5, 0x50, 0xb0,
                              //level=10 :
                              0x76, 0xbc, 0x9, 0x5, 0x50, 0xb0,
                              //level=11 :
                              0x40, 0xdc, 0x4, 0x5, 0x50, 0xb0,
                              //level=12 :
                              0x46, 0xd7, 0x6, 0x5, 0x50, 0xb0,
                              //level=13 :
                              0x4e, 0xd3, 0x6, 0x5, 0x50, 0xb0,
                              //level=14 :
                              0x56, 0xce, 0x7, 0x5, 0x50, 0xb0,
                              //level=15 :
                              0x5e, 0xca, 0x7, 0x5, 0x50, 0xb0,
                              //level=16 :
                              0x66, 0xc5, 0x8, 0x5, 0x50, 0xb0,
              
              };
              
              BYTE code TVPeakingCoeff[][6] =
              {
                              //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                              //level=0 :
                              0x0, 0x0, 0x0, 0x14, 0x50, 0xb0,
                              //level=1 :
                              0x4, 0x1, 0xfd, 0x16, 0x50, 0xb0,
                              //level=2 :
                              0x6, 0x2, 0xfb, 0x18, 0x50, 0xb0,
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 16  

                              //level=3 :
                              0xa, 0x3, 0xf8, 0x1a, 0x50, 0xb0,
                              //level=4 :
                              0xc, 0x5, 0xf5, 0x1c, 0x50, 0xb0,
                              //level=5 :
                              0x10, 0x6, 0xf2, 0x1e, 0x50, 0xb0,
                              //level=6 :
                              0x12, 0x7, 0xf0, 0x1f, 0x50, 0xb0,
                              //level=7 :
                              0x16, 0x8, 0xed, 0x1f, 0x50, 0xb0,
                              //level=8 :
                              0x1a, 0xa, 0xe9, 0x1f, 0x50, 0xb0,
                              //level=9 :
                              0x1c, 0xb, 0xe7, 0x1f, 0x50, 0xb0,
                              //level=10 :
                              0x20, 0xc, 0xe4, 0x1f, 0x50, 0xb0,
                              //level=11 :
                              0x22, 0xd, 0xe2, 0x1f, 0x50, 0xb0,
                              //level=12 :
                              0x26, 0xf, 0xde, 0x1f, 0x50, 0xb0,
                              //level=13 :
                              0x2c, 0x11, 0xd9, 0x1f, 0x50, 0xb0,
                              //level=14 :
                              0x32, 0x14, 0xd3, 0x1f, 0x50, 0xb0,
                              //level=15 :
                              0x38, 0x16, 0xce, 0x1f, 0x50, 0xb0,
                              //level=16 :
                              0x3e, 0x19, 0xc8, 0x1f, 0x50, 0xb0,
              };
              
              #elif(_Peaking_Coring_Table == SharpnessTable2)
              
              BYTE code PeakingCoeff[][6] =
              {
                              //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                              //level=1 :
                              0x08, 0x00, 0xFC, 0x00, 0x28, 0xF8,
                              //level=2 :
                              0x0C, 0x00, 0xFA, 0x00, 0x28, 0xF8,
                              //level=3 :
                              0x10, 0x00, 0xF8, 0x00, 0x28, 0xF8,
                              //level=4 :
                              0x18, 0x00, 0xF4, 0x00, 0x28, 0xF8,     //3
                              //level=5 :
                              0x20, 0x00, 0xF0, 0x00, 0x28, 0xF8,
                              //level=6 :
                              0x28, 0x00, 0xEC, 0x00, 0x28, 0xF8,
                              //level=7 :
                              0x30, 0x00, 0xE8, 0x00, 0x28, 0xF8,
                              //level=8 :
                              0x38, 0x00, 0xE4, 0x00, 0x28, 0xF8,
                              //level=9 :
                              0x40, 0x00, 0xE0, 0x00, 0x28, 0xF8,
                              //level=10 :
                              0x46, 0x00, 0xDD, 0x00, 0x28, 0xF8,
                              //level=11 :
                              0x4E, 0x00, 0xD9, 0x00, 0x28, 0xF8,
                              //level=12 :
                              0x56, 0x00, 0xD5, 0x00, 0x28, 0xF8,
                              //level=13 :
                              0x5E, 0x00, 0xD1, 0x00, 0x28, 0xF8,
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 17  

                              //level=14 :
                              0x66, 0x00, 0xCD, 0x00, 0x28, 0xF8,
                              //level=15 :
                              0x6E, 0x00, 0xC9, 0x00, 0x28, 0xF8,
                              //level=16 :
                              0x76, 0x00, 0xC5, 0x00, 0x28, 0xF8,
              };
              
              
              BYTE code TVPeakingCoeff[][6] =
               {
                              //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                              //level=1 :
                               0x08, 0x00, 0xFC, 0x12, 0x60, 0xF8,
                              //level=2 :
                               0x0A, 0x00, 0xFB,      0x12, 0x60, 0xF8,
                              //level=3 :
                               0x0C, 0x00, 0xFA,      0x12, 0x60, 0xF8,
                              //level=4 :
                               0x0E, 0x00, 0xF9,      0x12, 0x60, 0xF8,
                              //level=5 :
                               0x10, 0x00, 0xF8,      0x12, 0x60, 0xF8,
                              //level=6 :
                               0x12, 0x00, 0xF7,      0x12, 0x60, 0xF8,
                              //level=7 :
                               0x14, 0x00, 0xF6,      0x12, 0x60, 0xF8,
                              //level=8 :
                               0x16, 0x00, 0xF5,      0x12, 0x60, 0xF8,
                              //level=9 :
                               0x18, 0x00, 0xF4,      0x12, 0x60, 0xF8,
                              //level=10 :
                               0x1A, 0x00, 0xF3,      0x12, 0x60, 0xF8,
                              //level=11 :
                               0x1C, 0x00, 0xF2,      0x12, 0x60, 0xF8,
                              //level=12 :
                               0x1E, 0x00, 0xF1,      0x12, 0x60, 0xF8,
                              //level=13 :
                               0x20, 0x00, 0xF0,      0x12, 0x60, 0xF8,
                              //level=14 :
                               0x22, 0x00, 0xEF,      0x12, 0x60, 0xF8,
                               //level=15 :
                               0x24, 0x00, 0xEE,      0x12, 0x60, 0xF8,
                              //level=16 :
                               0x26, 0x00, 0xED,      0x12, 0x60, 0xF8,
              };
              #endif
              //----------------------------------------------------
              // CAdjustPeakingFilter
              // Adjust Peaking Filter and Coring Control
              // @param <Coefficient C0 of Peaking Filter>
              // @return {none}
              //----------------------------------------------------
              
              void CAdjustPeakingFilter(SBYTE ucPeaking)//锐度
              {
              #if (_Peaking_Coring_Table != SharpnessNoneTable)//reference Table
                      if((_GET_INPUT_SOURCE()==_SOURCE_VGA)||(_GET_INPUT_SOURCE()==_SOURCE_DVI) || (_GET_INPUT_SOURCE() == _SOU
             -RCE_HDMI))
                      {
                              CScalerPageSelect(_PAGE7);
                              CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x00);
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 18  

              
                              return;
                      }
                      else
                      {
              
                              if(_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV)
                              {
                                      pData[0] = TVPeakingCoeff[ucPeaking][0];
                                      pData[1] = TVPeakingCoeff[ucPeaking][1];
                                      pData[2] = TVPeakingCoeff[ucPeaking][2];
                                      pData[3] = TVPeakingCoeff[ucPeaking][3];
                                      pData[4] = TVPeakingCoeff[ucPeaking][4];
                                      pData[5] = TVPeakingCoeff[ucPeaking][5];
              
                              }
                              else
                              {
                                      pData[0] = PeakingCoeff[ucPeaking][0];
                                      pData[1] = PeakingCoeff[ucPeaking][1];
                                      pData[2] = PeakingCoeff[ucPeaking][2];
                                      pData[3] = PeakingCoeff[ucPeaking][3];
                                      pData[4] = PeakingCoeff[ucPeaking][4];
                                      pData[5] = PeakingCoeff[ucPeaking][5];
                              }
              
                              CScalerPageSelect(_PAGE7);
                              CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x80);
                              CScalerWrite(_P7_PC_DATA_PORT_D7, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x40);
              
                      }
              
              #else//default
              
                      if((_GET_INPUT_SOURCE() == _SOURCE_VGA)||(_GET_INPUT_SOURCE() == _SOURCE_DVI) || (_GET_INPUT_SOURCE() == 
             -_SOURCE_HDMI))
                              ucPeaking = ucPeaking * 2;
                      else
                              ucPeaking = ucPeaking * 8;
              
                      if(ucPeaking > 126)
                              ucPeaking = 126;
                      if(ucPeaking < 14 && ucPeaking > 0)
                              ucPeaking = 14;
                              
                      pData[0] = ((ucPeaking +1) >> 1) << 1;
                      if((bit)(ucPeaking & 0x01))
                      {
                              pData[1] = (SWORD)-72 * pData[0] / 126;
                              pData[2] = (SWORD)-(pData[0] + 2*pData[1]) / 2;
                      }
                      else
                      {
                              pData[1] = (SWORD)-73 * pData[0] / 126;
                              pData[2] = (SWORD)-(pData[0] + 2*pData[1]) / 2;
                      }
              
                      pData[3] = (BYTE)_CORING_MIN;
                      pData[4] = (BYTE)_CORING_MAX_POS;
                      pData[5] = (SBYTE)_CORING_MAX_NEG;
                      CScalerPageSelect(_PAGE7);
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 19  

                      CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x80);
                      CScalerWrite(_P7_PC_DATA_PORT_D7, 6, pData, _NON_AUTOINC);
                      CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x40);
              
              #endif
              }
              
              
              #endif
1106          
1107          //--------------------------------------------------
1108          // Description  : Adjust sharpness
1109          // Input Value  : None
1110          // Output Value : None
1111          //--------------------------------------------------
1112          void CAdjustPeakingCoding(void)
1113          {
1114   1              CAdjustPeakingFilter(GET_PEAKING_CORING());
1115   1      }
1116          
1117          //--------------------------------------------------
1118          // Description  : Adjust backlight
1119          // Input Value  : None
1120          // Output Value : None
1121          //--------------------------------------------------
1122          void CAdjustBacklight(void)
1123          {
1124   1          BYTE ucLight = 0;
1125   1      
1126   1          stSystemData.BackLight = stConBriData.Brightness;//GET_BRIGHTNESS();
1127   1      
1128   1          ucLight = (WORD)(_BACKLIGHT_MAX - _BACKLIGHT_MIN) * stSystemData.BackLight/100;
1129   1      
1130   1      #if(_BACKLIGHT_PWM_INVERSE == _ENABLE)
1131   1      
1132   1          ucLight = _BACKLIGHT_MAX - ucLight;
1133   1      
1134   1      #else
              
                  ucLight = _BACKLIGHT_MIN + ucLight;
              
              #endif
1139   1      
1140   1          CSetPWM(_BACKLIGHT_PWM, ucLight);
1141   1      }
1142          
1143          
1144          #if(_OSD_TYPE != _OSD007)
1145          void CAdjustGammaTable(BYTE index)
1146          {
1147   1          index = index;
1148   1      #if(_GAMMA_TYPE ==      _FULL_GAMMA_NORMAL_TABLE)
                      switch(index)
                  {
                      case 1:
                              CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_1_R, GAMMA_1_G, GAMMA_1_B);
                              break;
              
                      case 2:
                              CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_2_R, GAMMA_2_G, GAMMA_2_B);
                              break;
              
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 20  

                      case 3:
                              CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_3_R, GAMMA_3_G, GAMMA_3_B);
                              break;
              
                      case 0:
                              CScalerSetBit(_GAMMA_CTRL_67, ~_BIT6, 0x00);
                              break;
              
                      default:
                              break;
                      }
                      
              #elif(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)
              
                      switch(index)
                  {
                      case 0:         // disable Gamma
                              CScalerSetBit(_GAMMA_CTRL_67, ~_BIT6, 0x00);
                              break;
              
                      case 1:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_1_R, GAMMA_1_G, GAMMA_1_B);
                      break;
              
                  case 2:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_2_R, GAMMA_2_G, GAMMA_2_B);
                      break;
              
                  case 3:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_3_R, GAMMA_3_G, GAMMA_3_B);
                      break;
                  
                  default:
                      break;
                      }
              #endif
1195   1      }
1196          #endif
1197          
1198          #if(sRGB_Color_Enhance == _ENABLE)
1199          //Use sRGB to adjust Saturation and Hue
1200          void CAdjustSaturationHue(BYTE  ucValue, BOOL bSaturationIndex)
1201          {
1202   1      //Lewis, this table have multiplied by 1024
1203   1              INT16 code YUV2RGB[3][3] =
1204   1              {
1205   1                {1024,   0,      1436},
1206   1                {1024,   -342,   -731},
1207   1                {1024,   1815,   0}
1208   1               };
1209   1      
1210   1      //Lewis, this table have multiplied by 1024
1211   1              INT16 code RGB2YUV[3][3] =
1212   1              {
1213   1                  {306,     601,   117},
1214   1                {-173,   -339,    512},
1215   1                  {512,   -429,   -83}
1216   1               };
1217   1      
1218   1              BYTE i, j;
1219   1              INT16 temp_buff0[3][3];
1220   1              //731401***
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 21  

1221   1              //INT16 temp_buff1[3][3];
1222   1              //INT16 temp_buff2[3][3];
1223   1              INT16 MATRIX_GAIN_HUE[3][3];
1224   1              //INT16 MATRIX_GAIN[3][3];
1225   1              //INT16 MATRIX_HUE[3][3];
1226   1              //731401###
1227   1              INT16 temp_hue, temp_saturation;
1228   1      
1229   1      
1230   1              if(bSaturationIndex == _TRUE) //adjust saturation
1231   1              {
1232   2                      temp_saturation=(INT16)ucValue;
1233   2                      temp_hue=(INT16)GET_HUE() - 50;
1234   2              }
1235   1              else
1236   1              {
1237   2                      temp_saturation = (INT16)GET_SATURATION();
1238   2                      temp_hue=(INT16)ucValue - 50;
1239   2              }
1240   1      
1241   1              //Lewis 20060717, to prevent adjust CSC matrix, the saturation overflow
1242   1              if(temp_saturation>75)
1243   1                      temp_saturation = 75;
1244   1              else if(temp_saturation<25)
1245   1                      temp_saturation = 25;
1246   1      
1247   1              temp_hue = temp_hue*19>>5; //Lewis, 20060720, limited Hue range to prevent grey bar have color
1248   1      //731401***
1249   1      //Lewis, this table have multiplied by 1024
1250   1              MATRIX_GAIN_HUE[0][0] = 1024;
1251   1              MATRIX_GAIN_HUE[0][1] = 0;
1252   1              MATRIX_GAIN_HUE[0][2] = 0;
1253   1              MATRIX_GAIN_HUE[1][0] = 0;
1254   1              MATRIX_GAIN_HUE[1][1] = ((temp_saturation<<7)/25)<<2;
1255   1              MATRIX_GAIN_HUE[1][2] = 0;
1256   1              MATRIX_GAIN_HUE[2][0] = 0;
1257   1              MATRIX_GAIN_HUE[2][1] = 0;
1258   1              MATRIX_GAIN_HUE[2][2] = MATRIX_GAIN_HUE[1][1];
1259   1      
1260   1              CAdjustMatrixMultiply(MATRIX_GAIN_HUE,RGB2YUV,temp_buff0);
1261   1              
1262   1      //Lewis, this table have multiplied by 1024
1263   1              MATRIX_GAIN_HUE[0][0] = 1024;
1264   1              MATRIX_GAIN_HUE[0][1] = 0;
1265   1              MATRIX_GAIN_HUE[0][2] = 0;
1266   1              MATRIX_GAIN_HUE[1][0] = 0;
1267   1              MATRIX_GAIN_HUE[1][1] = CAdjustCosine(temp_hue);
1268   1              MATRIX_GAIN_HUE[1][2] = CAdjustSine(temp_hue);
1269   1              MATRIX_GAIN_HUE[2][0] = 0;
1270   1              MATRIX_GAIN_HUE[2][1] = (-1)*MATRIX_GAIN_HUE[1][2];//-CAdjustSine(temp);
1271   1              MATRIX_GAIN_HUE[2][2] = MATRIX_GAIN_HUE[1][1]; //CAdjustCosine(temp);
1272   1      
1273   1      
1274   1              CAdjustMatrixMultiply(MATRIX_GAIN_HUE,temp_buff0,temp_buff0);
1275   1              CAdjustMatrixMultiply(YUV2RGB,temp_buff0,temp_buff0);
1276   1      
1277   1              for(i=0; i<3; i++)
1278   1          {
1279   2                      for(j=0; j<3; j++)
1280   2              {
1281   3                      if (i==j)
1282   3                         temp_buff0[i][j]-=1024;
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 22  

1283   3          
1284   3                      temp_buff0[i][j] = temp_buff0[i][j]>>1;
1285   3          
1286   3                      if (temp_buff0[i][j]>255)
1287   3                              temp_buff0[i][j] = 255;
1288   3                      else if(temp_buff0[i][j]<-256)
1289   3                              temp_buff0[i][j] = -256;
1290   3              }
1291   2          }
1292   1      
1293   1              //Write R
1294   1              //frank CScalerSetBit(_COLOR_CTRL_62,0xc7,0x08);
1295   1              pData[0] =(temp_buff0[0][0]<0?1:0);
1296   1              pData[1]=(BYTE)(temp_buff0[0][0]);
1297   1              pData[2] =(temp_buff0[0][1]<0?1:0);
1298   1              pData[3]=(BYTE)(temp_buff0[0][1]);
1299   1              pData[4] =(temp_buff0[0][2]<0?1:0);
1300   1              pData[5]=(BYTE)(temp_buff0[0][2]);
1301   1      
1302   1      //      CAdjustSetsRGBRhue();
1303   1              CAdjustSetYpbprRhue();
1304   1      
1305   1              //Write G
1306   1              //frank CScalerSetBit(_COLOR_CTRL_62,0xc7,0x10);
1307   1      
1308   1              pData[0] =(temp_buff0[1][0]<0?1:0);
1309   1              pData[1]=(BYTE)(temp_buff0[1][0]);
1310   1              pData[2] =(temp_buff0[1][1]<0?1:0);
1311   1              pData[3]=(BYTE)(temp_buff0[1][1]);
1312   1              pData[4] =(temp_buff0[1][2]<0?1:0);
1313   1              pData[5]=(BYTE)(temp_buff0[1][2]);
1314   1      
1315   1      //      CAdjustSetsRGBGhue();
1316   1              CAdjustSetYpbprGhue();
1317   1      
1318   1              //Write B
1319   1      
1320   1              pData[0] =(temp_buff0[2][0]<0?1:0);
1321   1              pData[1]=(BYTE)(temp_buff0[2][0]);
1322   1              pData[2] =(temp_buff0[2][1]<0?1:0);
1323   1              pData[3]=(BYTE)(temp_buff0[2][1]);
1324   1              pData[4] =(temp_buff0[2][2]<0?1:0);
1325   1              pData[5]=(BYTE)(temp_buff0[2][2]);
1326   1      //731401###
1327   1      //      CAdjustSetsRGBBhue();
1328   1              CAdjustSetYpbprBhue();
1329   1      
1330   1              CScalerSetBit(_COLOR_CTRL_62, 0xff, 0x80);                      // cftsai 20061031 added, ready to write
1331   1      }
1332          
1333          INT16 CAdjustCosine(INT16 fDegree)
1334          {
1335   1              //Lewis, the curve value table have multiplied by 1024
1336   1              UINT16 code fCosCurveAngle[13] = {   0,   6,  12,  18,  24,  30,  37,  44,  52,  60,  68,  78, 90};
1337   1              UINT16 code fCosCurveValue[13] = {1024, 1018, 1002, 974, 935, 887, 818, 737, 630, 512, 384, 213,  0};
1338   1              UINT8 i,cQuadrant;
1339   1              INT16 fDegreeTemp, fDegreeSpan, fCosValueSpan, fCosValue;
1340   1      
1341   1              if (fDegree < 0)
1342   1                      fDegree += 360;
1343   1      
1344   1              fDegree = fDegree%360;
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 23  

1345   1      
1346   1              //locate degree on which quadrant
1347   1              cQuadrant = (UINT8)(fDegree / 90);
1348   1              cQuadrant++;
1349   1              if (cQuadrant==1) //first quadrant
1350   1                      fDegree = fDegree;
1351   1              else if(cQuadrant==2) //second quadrant
1352   1                      fDegree = 180 - fDegree;
1353   1              else if(cQuadrant==3) //third quadrant
1354   1                      fDegree = fDegree - 180;
1355   1              else if(cQuadrant==4) //forth quadrant
1356   1                      fDegree = 360 -fDegree;
1357   1              //locate degree on which quadrant
1358   1      
1359   1              if (fDegree<=fCosCurveAngle[0])
1360   1                      fCosValue = fCosCurveValue[0];
1361   1              else
1362   1              {
1363   2                      for (i=0;fCosCurveAngle[i] < fDegree; i++);
1364   2      
1365   2                      i--;
1366   2                      fDegreeTemp = fDegree-fCosCurveAngle[i];
1367   2                      fDegreeSpan = fCosCurveAngle[i+1]-fCosCurveAngle[i];
1368   2                      fCosValueSpan = fCosCurveValue[i+1]-fCosCurveValue[i];
1369   2                      fCosValue = fCosCurveValue[i]+fDegreeTemp*fCosValueSpan/fDegreeSpan;
1370   2              }
1371   1      
1372   1              if (cQuadrant==2 || cQuadrant==3)
1373   1                      fCosValue = fCosValue*(-1);
1374   1      
1375   1              return fCosValue;
1376   1      }
1377          
1378          INT16 CAdjustSine(INT16 fDegree)
1379          {
1380   1              //Lewis, this table have multiplied by 1024
1381   1              UINT16 code fSinCurveAngle[13] = {0,   6,  12,  18,  24,  30,  37,  44,  52,  60,  68,  78, 90};
1382   1              UINT16 code fSinCurveValue[13] = {0, 107, 213, 316, 416, 512, 616, 711, 807, 887, 949, 1002,  1024};
1383   1              UINT8 i,cQuadrant;
1384   1              INT16 fDegreeTemp,fDegreeSpan,fSinValueSpan,fSinValue;
1385   1      
1386   1              if (fDegree < 0)
1387   1                      fDegree += 360;
1388   1      
1389   1              fDegree = fDegree%360;
1390   1      
1391   1              //locate degree on which quadrant
1392   1              cQuadrant = (UINT8)(fDegree / 90);
1393   1              cQuadrant++;
1394   1              if (cQuadrant==1) //first quadrant
1395   1                      fDegree = fDegree;
1396   1              else if(cQuadrant==2) //second quadrant
1397   1                      fDegree = 180 - fDegree;
1398   1              else if(cQuadrant==3) //third quadrant
1399   1                      fDegree = fDegree - 180;
1400   1              else if(cQuadrant==4) //forth quadrant
1401   1                      fDegree = 360 -fDegree;
1402   1              //locate degree on which quadrant
1403   1      
1404   1              if (fDegree<=fSinCurveAngle[0])
1405   1                      fSinValue = fSinCurveValue[0];
1406   1              else
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 24  

1407   1              {
1408   2                      for (i=0;fSinCurveAngle[i] < fDegree; i++);
1409   2      
1410   2                      i--;
1411   2                      fDegreeTemp = fDegree-fSinCurveAngle[i];
1412   2                      fDegreeSpan = fSinCurveAngle[i+1]-fSinCurveAngle[i];
1413   2                      fSinValueSpan = fSinCurveValue[i+1]-fSinCurveValue[i];
1414   2                      fSinValue = fSinCurveValue[i]+fDegreeTemp*fSinValueSpan/fDegreeSpan;
1415   2              }
1416   1      
1417   1              if (cQuadrant==3 || cQuadrant==4)
1418   1                      fSinValue = fSinValue*(-1);
1419   1      
1420   1              return fSinValue;
1421   1      }
1422          
1423          void CAdjustMatrixMultiply(INT16 (*arrayA)[3], INT16 (*arrayB)[3], INT16 (*arrayC)[3])
1424          {
1425   1              BYTE i, j;
1426   1              INT32 Temp[3][3];
1427   1      
1428   1              for(i=0; i<3; i++)
1429   1              {
1430   2                      for(j=0; j<3; j++)
1431   2                      {
1432   3                              Temp[i][j] = ((INT32)arrayA[i][0]*arrayB[0][j]>>2)
1433   3                                                      + ((INT32)arrayA[i][1]*arrayB[1][j]>>2)
1434   3                                                      + ((INT32)arrayA[i][2]*arrayB[2][j]>>2);
1435   3      
1436   3                              //arrayC[i][j] = (INT16)(Temp[i][j]>>8);//731401
1437   3                      }
1438   2              }
1439   1      
1440   1              for(i=0; i<3; i++)
1441   1              {
1442   2                      for(j=0; j<3; j++)
1443   2                      {
1444   3                              arrayC[i][j] = (INT16)(Temp[i][j]>>8);
1445   3                      }
1446   2              }
1447   1      
1448   1      }
1449          
1450          #endif
1451          
1452          
1453          
1454          BYTE code SatPlus[8]  = { 41, 44, 43, 39, 31, 22, 11, 0 }; // by 1/256
1455          BYTE code SatMinus[8] = { 24, 35, 40, 41, 36, 28, 16, 0 }; // by 1/256
1456          
1457          int CAdjustColorGammaCal(BYTE color, BYTE n) // n = 1~8
1458          {
1459   1              BYTE temp;
1460   1      
1461   1              if (color == 0)         //R
1462   1                      temp = GET_ICM_SAT_R();
1463   1              else if (color== 1)     //G
1464   1                      temp = GET_ICM_SAT_G();
1465   1              else if (color == 2)//B
1466   1                      temp = GET_ICM_SAT_B();
1467   1              else if (color == 3)//Y
1468   1                      temp = GET_ICM_SAT_Y();
C51 COMPILER V9.00   ADJUST_CUSTOMER                                                       08/25/2023 16:47:31 PAGE 25  

1469   1              else if (color == 4)//C
1470   1                      temp = GET_ICM_SAT_C();
1471   1          temp *= 2;  //Since the scale for OSD(from 0~16) and cloor(from 0~32) is different, we will have to mu
             -ltiply
1472   1                                 //temp by 2 to make up the difference
1473   1          if (temp >= 16)
1474   1          {
1475   2                      return ((int)(512*n) + (int)((temp-16)*(int)SatPlus[n-1])) / 64 ;
1476   2          }
1477   1          else
1478   1          {
1479   2                      return ((int)(512*n) - (int)((16-temp)*(int)SatMinus[n-1])) / 64 ;
1480   2          }
1481   1      }
1482          
1483          #define CENTER    0x00
1484          #define RIGHT     0x10
1485          #define LEFT      0x20
1486          
1487          void CAdjustMZHueSat(BYTE color)
1488          {
1489   1              //Value  0~4095 => angle 0~359
1490   1              //R / G / B / Y /C
1491   1              //range  256 => 22.5  degree
1492   1              //buffer 128 => 11.25 degree
1493   1              //R / G / B
1494   1              //range  512 => 45    degree
1495   1              //buffer 128 => 11.25 degree
1496   1              CTimerWaitForEvent(_EVENT_DEN_STOP);
1497   1              CAdjustSetHueUVDelta(color, CENTER);
1498   1              CAdjustSetHueUVDelta(color, RIGHT);
1499   1              CAdjustSetHueUVDelta(color, LEFT);
1500   1      
1501   1              CScalerPageSelect(_PAGE7);
1502   1              CScalerSetBit(_P7_ICM_CTRL_D0, ~_BIT7, _BIT7);
1503   1      
1504   1      }
1505          
1506          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3861    ----
   CONSTANT SIZE    =    203    ----
   XDATA SIZE       =   ----     182
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
