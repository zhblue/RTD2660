C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SCALER
OBJECT MODULE PLACED IN .\Output\Scaler.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil\C51\BIN\C51.EXE Core\code\rtd2662\Scaler.c LARGE OPTIMIZE(9,SPEED) BROW
                    -SE DEBUG OBJECTEXTEND PRINT(.\Output\Scaler.lst) OBJECT(.\Output\Scaler.obj)

line level    source

   1          //----------------------------------------------------------------------------------------------------
   2          // ID Code      : Scaler.c No.0003
   3          // Update Note  :
   4          //
   5          //----------------------------------------------------------------------------------------------------
   6          
   7          #define __SCALER__
   8          
   9          #include "Core\Header\Include.h"
  10          
  11          //--------------------------------------------------
  12          // Description  : Get bytes from selected register in data port
  13          // Input Value  : ucAddr    --> Access Port Address of register
  14          //                ucValue   --> Data Port Address we want to Get
  15          //                ucLength  --> Numbers of data we want to read
  16          //                pArray    --> Pointer of the reading data array
  17          //                bAutoInc  --> Address auto increasing select
  18          // Output Value : None
  19          //--------------------------------------------------
  20          
  21          #if(_HDCP_SUPPORT == _ON)
  22          void CScalerGetDataPortByte(BYTE ucAddr, BYTE ucValue, BYTE ucLength, BYTE *pArray, BIT bAutoInc)
  23          {
  24   1          if(ucLength > 0)
  25   1          {
  26   2              if((ucAddr == _SU_ACCESS_PORT_33) || (ucAddr == _HW_ACCESS_PORT_60) 
  27   2              || (ucAddr == _CB_ACCESS_PORT_64) || (ucAddr == _PC_ACCESS_PORT_9A))
  28   2              {
  29   3                  CScalerSetByte(ucAddr, 0x80);
  30   3                  ucValue = ucValue | 0x80;
  31   3              }
  32   2      
  33   2              CScalerSetByte(ucAddr, ucValue);
  34   2              CScalerRead( ucAddr + 1, ucLength, pArray, bAutoInc);
  35   2          }
  36   1      }
  37          #endif
  38          
  39          //--------------------------------------------------
  40          // Description  : Initial settings for scaler
  41          // Input Value  : None
  42          // Output Value : None
  43          //--------------------------------------------------
  44          void CScalerInitial(void)
  45          {
  46   1          // Software reset for scaler
  47   1          CScalerSetBit(_HOST_CTRL_01, ~_BIT0, _BIT0);//      Èí¼þ¸´Î»
  48   1          CTimerDelayXms(20);
  49   1          CScalerSetBit(_HOST_CTRL_01, ~_BIT0, 0x00);
  50   1          //CIrdaInitial();//ºìÍâÉè¶¨
  51   1              CScalerCodeW(tSCALER_POWERUP_INITIAL);//¼Ä´æÆ÷ÖµÉè¶¨
  52   1              
  53   1      #if(_YPBPR_SUPPORT && _YPBPR_HW_AUTO_SOY == _ENABLE)
  54   1              CYPbPrHWAutoSOY();
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 2   

  55   1      #endif
  56   1      
  57   1      #if (_HDMI_SUPPORT == _ON)
  58   1              CScalerCodeW(tSCALER_POWERUP_HDMI);
  59   1      #else
                      CScalerCodeW(tSCALER_POWERUP_DVI);
              #endif  
  62   1      
  63   1          CScalerReset();
  64   1      
  65   1      #if(_HDCP_SUPPORT == _ON)
  66   1              //bHPD = 0;//Hot Plug Detect Pull LOW
  67   1              bHot_Plug = _HOT_PLUG_LOW;//bHot_Plug = 0;
  68   1              CAdjustHDCP();//HDCP1.0 for DVI
  69   1              //bHPD = 1;//Hot Plug Detect Pull HIGH
  70   1              CTimerDelayXms(100);//20070714 gary for HDMI compatibility problem
  71   1      //      bHot_Plug = _HOT_PLUG_HI;//bHot_Plug = 1;
  72   1              CTimerDelayXms(100);//CTimerDelayXms(1000);             
  73   1      #endif
  74   1      //Alanli20070801###
  75   1      
  76   1      }
  77          
  78          
  79          //--------------------------------------------------
  80          // Description  : Reset scaler process
  81          // Input Value  : None
  82          // Output Value : None
  83          //--------------------------------------------------
  84          void CScalerReset(void)
  85          {
  86   1              CScalerCodeW(tSCALER_RESET_TABLE);
  87   1          /*
  88   1              CScalerCodeW(tSCALER_POWERUP_INITIAL);
  89   1      #if (_HDMI_SUPPORT == _ON)
  90   1              //if(CHdmiFormatDetect())//Input source is the HDMI format.
  91   1                      CScalerCodeW(tSCALER_POWERUP_HDMI);
  92   1              //else//DVI
  93   1      #else
  94   1                      CScalerCodeW(tSCALER_POWERUP_DVI);
  95   1      #endif     */
  96   1              CMiscSetPinShare();
  97   1      
  98   1              CAdjustDisableWatchDog(_WD_ALL);
  99   1      
 100   1              CMiscClearStatusRegister();
 101   1      
 102   1              CScalerInitialDisplayInterface();
 103   1      
 104   1              CScalerInitialDisplayOutput();
 105   1      
 106   1              CModeSetFreeRun();
 107   1          /*
 108   1          //EricLee add for VGA
 109   1          if (_GET_INPUT_SOURCE() == _SOURCE_VGA)
 110   1          {
 111   1              CScalerPageSelect(_PAGE0);
 112   1              CScalerSetByte(_P0_ADC_DCR_CTRL_D3,0x11);
 113   1              //CScalerSetByte(_P0_ADC_CLAMP_CTRL0_D4,0x00);
 114   1          }        */
 115   1      
 116   1              if(GET_POWERSTATUS())
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 3   

 117   1              {
 118   2              CScalerEnableDisplayOutput();
 119   2              // OSD power up initial
 120   2              CScalerCodeW(tOSD_POWERUP_INITIAL);
 121   2              //EricLee add for YPBPR
 122   2              if (_GET_INPUT_SOURCE() == _SOURCE_YPBPR)
 123   2              {
 124   3                      CScalerPageSelect(_PAGE0);
 125   3                      CScalerSetByte(_P0_ADC_DCR_CTRL_D3,0x11);
 126   3                      CScalerSetByte(_P0_ADC_CLAMP_CTRL0_D4,0x00);
 127   3              }        
 128   2      
 129   2              CAdjustTMDSErrorCorrectionOn();
 130   2              //CAdjustSRGB();
 131   2      #if(_GAMMA_TYPE ==      _COMPACT_GAMMA_NORMAL_TABLE)
                      CAdjustGamma(_COMPACT_GAMMA_NORMAL_TABLE, tGAMMA_COMPACT1, tGAMMA_COMPACT1, tGAMMA_COMPACT1);//Ù¤Â
             -íÖµ
              #elif(_GAMMA_TYPE == _FULL_GAMMA_NORMAL_TABLE)||(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)    
                      CAdjustGammaTable(GET_GAMMA());
              #endif
 136   2      
 137   2              if(GET_18BIT_EN() == _DISP_18_BIT)
 138   2                      CAdjustDither(tDITHER_SEQ_TABLE_0, tDITHER_TABLE_10_TO_6);
 139   2                      
 140   2              else if(GET_18BIT_EN() == _DISP_24_BIT)
 141   2                      CAdjustDither(tDITHER_SEQ_TABLE_0, tDITHER_TABLE_10_TO_8);
 142   2      
 143   2                      CScalerSetBit(_IPH_ACT_WID_H_16, ~(_BIT6 | _BIT5 | _BIT4), 0x00);
 144   2                      //if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
 145   2                      //      CScalerSetBit(_IPH_ACT_WID_H_16, ~(_BIT6 | _BIT5 | _BIT4), ((_ADC0_INPUT_SWAP_RG << 4) | (_ADC0_INPUT
             -_SWAP_RB << 5)| (_ADC0_INPUT_SWAP_GB << 6)));
 146   2                      //else if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
 147   2                      //      CScalerSetBit(_IPH_ACT_WID_H_16, ~(_BIT6 | _BIT5 | _BIT4), ((_ADC1_INPUT_SWAP_RG << 4) | (_ADC1_INPUT
             -_SWAP_RB << 5)| (_ADC1_INPUT_SWAP_GB << 6)));         
 148   2                      
 149   2              CAdjustBrightness();
 150   2                      CAdjustContrast();
 151   2      
 152   2      #if(_OD_SUPPORT == _ON)
                              CMemoryLoadODLUT(_OD_TABLE_COMMON);
                              CMemorySDRAMReset();
              #endif
 156   2              }
 157   1              else
 158   1              {
 159   2                      CPowerDPLLOff();
 160   2                      //CScalerSetByte(_HOST_CTRL_01, 0x42);//731301
 161   2                      CScalerSetBit(_HOST_CTRL_01, ~_BIT1,(_BIT4 | _BIT1)); //V307 modify//731301
 162   2                      CScalerDisableDisplayOutput();
 163   2              }
 164   1      }
 165          
 166          //--------------------------------------------------
 167          void CCustomerInitial(void)
 168          {
 169   1         //@ For RTD2662 version auto detect using.
 170   1         CScalerPageSelect(_PAGE0);//eric 20070529
 171   1         CScalerRead(_P0_POWER_ON_RESET_F3, 1, &pData[0], _NON_AUTOINC);
 172   1      
 173   1         if((pData[0]&0xC0) == 0xC0)
 174   1         {//@Version B
 175   2              CScalerSetByte(_TCON_ADDR_PORT_8B, _LVDS_CTRL1_A1);
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 4   

 176   2              CScalerSetByte(_TCON_DATA_PORT_8C, 0xD7);
 177   2         }
 178   1         else
 179   1         {//@Version A
 180   2              CScalerSetByte(_TCON_ADDR_PORT_8B, _LVDS_CTRL1_A1);
 181   2              CScalerSetByte(_TCON_DATA_PORT_8C, 0x17);
 182   2         }
 183   1      }
 184          
 185          //--------------------------------------------------
 186          // Description  : Initial display interface for TTL, LVDS and RSDS
 187          // Input Value  : None
 188          // Output Value : None
 189          //--------------------------------------------------
 190          void CScalerInitialDisplayInterface(void)
 191          {
 192   1          BYTE ucLVDSMapTemp;
 193   1      
 194   1          CScalerSetByte(_TCON_ADDR_PORT_8B, _TCON_LVDS_CTRL3_A3);     
 195   1              CScalerRead(_TCON_DATA_PORT_8C, 1, &ucLVDSMapTemp, _NON_AUTOINC);
 196   1          ucLVDSMapTemp &= 0xFE;
 197   1          if (!GET_LVDS_MAP()) // MAP2
 198   1              ucLVDSMapTemp |= 0x01;
 199   1      
 200   1              switch(GET_PNL_OUTPUT_BUS())
 201   1              {
 202   2              case _PANEL_TTL:
 203   2                      CScalerCodeW(tTTL_INITIAL);
 204   2                      break;
 205   2      
 206   2              case _PANEL_LVDS:
 207   2                      CScalerCodeW(tLVDS_INITIAL);
 208   2                      break;
 209   2      
 210   2              case _PANEL_RSDS:
 211   2                      CScalerCodeW(tLVDS_INITIAL);
 212   2                              CScalerCodeW(tRSDS_INITIAL);
 213   2                      //CScalerSetByte(_TCON_ADDR_PORT_8B, 0x02);
 214   2                      //CScalerSetByte(_TCON_DATA_PORT_8C, 0x40 | ((Panel[ucPanelSelect]->PanelStyle & 0xE0) >> 5));
 215   2                      //CScalerSetBit(_DISP_TIMING_46, ~_BIT0, _BIT0);
 216   2                      break;
 217   2              }
 218   1      
 219   1          // Set LVDS MAP
 220   1          CScalerSetByte(_TCON_ADDR_PORT_8B, _TCON_LVDS_CTRL3_A3);     
 221   1              CScalerSetByte(_TCON_DATA_PORT_8C, ucLVDSMapTemp);
 222   1      
 223   1          // Eric Lee add for IC version auto detect
 224   1          CCustomerInitial();
 225   1      }
 226          
 227          //--------------------------------------------------
 228          // Description  : Initial display output from Panel.h settings
 229          // Input Value  : None
 230          // Output Value : None
 231          //--------------------------------------------------
 232          void CScalerInitialDisplayOutput(void)
 233          {
 234   1              // Display signal control settings
 235   1              BYTE ucTemp = 0x00;
 236   1              if(GET_18BIT_EN() == _DISP_18_BIT)
 237   1              {
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 5   

 238   2                  ucTemp |= _BIT4;
 239   2              }
 240   1      
 241   1              if(GET_DOUBLE_PORT_EN() == _DISP_DOUBLE_PORT)
 242   1              {
 243   2              ucTemp |= _BIT2; 
 244   2              }
 245   1          
 246   1              CScalerSetBit(_VDISP_CTRL_28, ~(_BIT4 | _BIT2), ucTemp);
 247   1              CScalerSetByte(_VDISP_SIGINV_29, Panel[ucPanelSelect]->PanelConfig & (~_BIT3));
 248   1      }
 249          
 250          //--------------------------------------------------
 251          // Description  : Enable display output
 252          // Input Value  : None
 253          // Output Value : None
 254          //--------------------------------------------------
 255          void CScalerEnableDisplayOutput(void)
 256          {
 257   1              CScalerSetBit(_VDISP_CTRL_28, ~(_BIT6 | _BIT1), _BIT1);
 258   1              CScalerSetBit(_VDISP_CTRL_28, ~_BIT0, _BIT0);
 259   1      
 260   1              CScalerSetBit(_VDISP_CTRL_28, ~_BIT7, _BIT7);
 261   1              CScalerSetBit(_VDISP_CTRL_28, ~_BIT7, 0x00);
 262   1      }
 263          
 264          //--------------------------------------------------
 265          // Description  : Disable display output
 266          // Input Value  : None
 267          // Output Value : None
 268          //--------------------------------------------------
 269          void CScalerDisableDisplayOutput(void)
 270          {
 271   1              CScalerSetBit(_VDISP_CTRL_28, ~(_BIT6 | _BIT1), _BIT6);
 272   1              CScalerSetBit(_VDISP_CTRL_28, ~_BIT0, 0x00);
 273   1      }
 274          
 275          #if(_NONLINEAR_SCALING)
              
              //--------------------------------------------------
              // Description  : Disable Nonlinear scale up function
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CScalerDisableNonlinearScaleUp(void)
              {
                      ((DWORD*) pData)[0] = 0; //Disable non linear scale up first
                      
                      CScalerSetByte(_SU_ACCESS_PORT_33, 0x8c);
                      CScalerSetByte(_SU_ACCESS_PORT_33, 0x8c);
                      CScalerWrite(_SU_DATA_PORT_34, 4, pData, _NON_AUTOINC);
                      CScalerSetByte(_SU_ACCESS_PORT_33, 0x00);
              }
              
              //--------------------------------------------------
              // Description  : Disable Nonlinear scale down function
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CScalerDisableNonlinearScaleDown(void)
              {
                  
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 6   

                      CScalerSetBit(_SCALE_DOWN_CTRL_23, 0xf7, 0x00);//disable non-linear scale down
              }
              
              //--------------------------------------------------
              // Description  : Progress the Nonlinear scale up
              // Input Value  :
              //                Option : Indicate whether scale up be acyivate now
              // Output Value : None
              //--------------------------------------------------
              void CScalerNonlinearScaleUp(BYTE Option)
              {
              
                      UINT8 FlatSuFac = 0;
                      UINT8 InitSuFac = 0;
                      UINT16 w1;      // segment1 pixel
                      UINT16 w2;      // segment2 pixel
                      UINT16 w3;      // segment3 pixel
                      UINT8 SU_Waighting;//range from 35 ~ 45
              
                      if(GET_NONLINEAR_VALUE() == 0)
                      {
                              CTimerDelayXms(120);
                      CScalerSetByte(_STATUS0_02, 0x00);
                      return;
                      }
              
                      SU_Waighting =  35 + GET_NONLINEAR_VALUE();
              
                      if(Option & _BIT2)
                      {
                              w1 = stDisplayInfo.DHWidth/5 + 71;
                              w2 = w1 - 71; //w2
                              w3 = stDisplayInfo.DHWidth - SHL(w1, 1) - SHL(w2, 1); //w3
              
              #if(_NONLINEAR_SCALEUP_METHOD == _BOUL)
                              ((unsigned int *) pData)[2] = stDisplayInfo.DHWidth;
              
                              FlatSuFac = (DWORD)512 * stModeInfo.IHWidth* 4 /((unsigned int *) pData)[2] / 5;
                              FlatSuFac = FlatSuFac & 0x0001 ? SHR(FlatSuFac + 1, 1) : SHR(FlatSuFac, 1);//round
              
                              //Csu > Fsu
                              //Fsu - Csu < 0
                              //Fsu(w1 + w2) - [Xm - Su(w1 + 1) - Fsu(1 + w2 + w3)] < 0
                              //Fsu(1 + w1 + 2w2 + w3) - Xm + Su(w1 + 1) < 0
                              //Su < [Xm - Fsu(1 + w1 + 2w2 + w3)]/(w1 + 1)
              
                              ((unsigned long *) pData)[3] = 512 * ((DWORD)(stModeInfo.IHWidth - 1) -
                                                                                              (DWORD)FlatSuFac * (w1 + SHL(w2, 1) + w3) /     255)
                                                                                              /(DWORD)(w1 + 1);
                            ((unsigned long *) pData)[3] = ((unsigned long *) pData)[3] & 0x00000001 ?
                              SHR(((unsigned long *) pData)[3] + 1, 1) : SHR(((unsigned long *) pData)[3], 1);//round
              
                              //ucInit_SU_Fac = ((unsigned long*)Data)[3] > 254 ? 254 : (BYTE)((unsigned long*)Data)[3]; //scaling fac
             -tor can't larger than 1
                              if (((unsigned long *) pData)[3] > 254)
                              {
                                      return;
                              }
                              else
                                      InitSuFac = ((unsigned long *) pData)[3];
              #else
                              //Set the initial scale up factor equal to average scale up factor * 0.2
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 7   

                              //Calculate the scaling factor normalize to 255
                              ((UINT32*)pData)[0] = (UINT32)255 * stModeInfo.IHWidth / stDisplayInfo.DHWidth;
                              InitSuFac = SHR(((UINT32*)pData)[0]*3 , 2);
              
              
                              //Fsu > Csu
                              //Fsu - Csu > 0
                              //Fsu - [Xm - Su(w1 + 1) - Fsu(1 + w2 + w3)]/(w1 + w2) > 0
                              //Fsu(w1 + w2) - [Xm - Su(w1 + 1) - Fsu(1 + w2 + w3)] > 0
                              //Fsu(1 + w1 + 2w2 + w3) - Xm + Su(w1 + 1) > 0
                              //Fsu > [Xm - Su(w1 + 1)]/(1 + w1 + 2w2 + w3)
                              ((UINT32*)pData)[3] = 255 * ((UINT32)(stModeInfo.IHWidth - 1) -
                                                                      (UINT32)w1 * InitSuFac / 255) /(w1 + SHL(w2, 1) + w3 - 8);
                              if (((UINT32*)pData)[3] > 254)
                              {
                                      return;
                              }
                              else
                              {
                                      //FlatSuFac = (SHR(((UINT32*)pData)[0] * 3, 1) > 255) ? 255 : SHR(((UINT32*)pData)[0] * 3, 1);
                                      FlatSuFac = (SHR(((UINT32*)pData)[0] * SU_Waighting, 5) > 255) ? 255 : SHR(((UINT32*)pData)[0] * SU_Wai
             -ghting, 5);
              
                              }
              
              #endif
                              //((UINT32 *) pData)[3] = 16777216 * (UINT32) InitSuFac / 255 + 0x00000008;
                              ((UINT32 *) pData)[3] = 1048576 * (UINT32) InitSuFac / 255;
              
                              CTimerWaitForEvent(_EVENT_DEN_STOP);
                            pData[0] = ((((DWORD *) pData)[3] >> 16) & 0x0f);
                              pData[1] = ((((DWORD *) pData)[3] >> 8) & 0xff);
                              pData[2] = ((((DWORD *) pData)[3]) & 0xff);
              
              
                              CScalerSetByte(_SU_ACCESS_PORT_33, 0x80); //don't remove this code thus the value can be fill in registe
             -r
                              CScalerSetByte(_SU_ACCESS_PORT_33, 0x80);
                             CScalerWrite(_SU_DATA_PORT_34, 3, pData, _NON_AUTOINC);
                             CScalerSetByte(_SU_ACCESS_PORT_33, 0x00);
              
              
                              //Calculate Csu = (Xm - Su(w1 + 1) - Fsu(1 + w2 + w3))/(w1 + w2)
                              ((UINT32*)pData)[2] = 1048576 * ((UINT32)stModeInfo.IHWidth -
                                                                      (UINT32)InitSuFac * w1 / 255 -
                                                                      (UINT32)FlatSuFac * (w2 + w3 - 1) / 255) /(w1 + w2 - 2);
              
                              //Calculate SU
                              ((UINT32*)pData)[3] = SHR((2097152 * (UINT32)InitSuFac /255) + 1, 1);
              
                              if (((unsigned long *)pData)[3] > ((unsigned long *) pData)[2]) {
                                      ((unsigned long *) pData)[3] = 0 -(((unsigned long *) pData)[3] -
                                                                                                         ((unsigned long *) pData)[2]) /(DWORD)w1; //The MSB is sign bit
                              }
               else {
                                     if (((unsigned long *)pData)[3] > ((unsigned long *) pData)[2]) {
                                              ((unsigned long *) pData)[3] = 0 -(((unsigned long *) pData)[3] -
                                                                                                         ((unsigned long *) pData)[2]) /(DWORD)w1; //The MSB is sign bit
                                      } else {
                                      //Calculate d1
                                      ((UINT32*) pData)[3] = (((UINT32*)pData)[2] - ((UINT32*)pData)[3]) / (UINT32)w1;
                                      }
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 8   

              
                                      pData[6] = ((((DWORD *) pData)[3] >> 8) & 0xff);
                                      pData[7] = (((DWORD *) pData)[3]  & 0xff);
              
                                      //Calculate Fsu
                                      ((UINT32*)pData)[3] = SHR((2097152 * (UINT32)FlatSuFac / 255) + 1, 1);
              
                              if (((unsigned long *) pData)[3] > ((unsigned long *) pData)[2]) {
                                              ((UINT32*)pData)[3] = (((UINT32*)pData)[3] - ((UINT32*)pData)[2]) / (UINT32)w2;
                              }else{
                                              ((unsigned long *) pData)[3] = 0 -      (((unsigned long *) pData)[2] - ((unsigned 
             -long *) pData)[3]) /(DWORD)w2;
                              }
              
                            }
              
                              pData[8] = ((((DWORD *) pData)[3] >> 8) & 0xff);
                              pData[9] = (((DWORD *) pData)[3] & 0xff);
              
              #if(_NONLINEAR_SCALEUP_METHOD == _BOUL)
                      w2 += 1;
                              w3 += 1;
              #else
                              w1 -= 1;
                              w2 -= 1;
                              w3 -= 1;
              #endif
              
                      pData[0] = AND(HIBYTE(w1), 0x07);
                              pData[1] = LOBYTE(w1);
                              pData[2] = AND(HIBYTE(w2), 0x07);
                              pData[3] = LOBYTE(w2);
                              pData[4] = AND(HIBYTE(w3), 0x07);
                              pData[5] = LOBYTE(w3);
              
                              CScalerSetByte(_SU_ACCESS_PORT_33, 0x86);  //don't remove this code thus the value can be fill in regist
             -er
                              CScalerSetByte(_SU_ACCESS_PORT_33, 0x86);
                      CScalerWrite(_SU_DATA_PORT_34, 10, pData, _NON_AUTOINC);
                      CScalerSetByte(_SU_ACCESS_PORT_33, 0x00);
                              CTimerDelayXms(120);
                      CScalerSetByte(_STATUS0_02, 0x00);
                  }
              }
              
              //--------------------------------------------------
              // Description  : Progress the Nonlinear scale up
              // Input Value  :
              //                Option : Indicate whether scale up be acyivate now
              // Output Value : None
              //--------------------------------------------------
              void CScalerNonlinearScaleDown(BYTE Option)
              {
                      UINT8 FlatSdFac;//This value must large than 64, scale down factor can't exceed 4 times
                      UINT16 w1;
                      UINT16 w2;
              
                      //if(FlatSdFac < 68)
                      //   return;
                      if(GET_NONLINEAR_VALUE() == 0)
                      {
                         //CScalerSetBit(_SCALE_DOWN_CTRL_23, 0xf7, 0x00);//disable non-linear scale down
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 9   

                      return;
                      }
                      
                  FlatSdFac =  68 + (10 - GET_NONLINEAR_VALUE());     //range from 68 ~ 78
              
                      if (Option & _BIT3 ) // non-linear scaling down
                      {
                              w1 = SHR(stDisplayInfo.DHWidth, 2);
                              w2 = (stDisplayInfo.DHWidth - SHL(w1, 1)) - 1;
              
              
                              //Calculate the Initial Scale down factor
                              ((UINT32*)pData)[3] = 1048576 * ((UINT32)((UINT32)stModeInfo.IHWidth - 1) -
                                      (w1 + w2) * (UINT32)FlatSdFac / 64) / w1;
              
                              //Data[0] = 5;
                              //Data[1] = info->channel ? _P1_47_H_SCALE : _P1_27_H_SCALE_DH;
                              pData[0] = pData[13];
                              pData[1] = pData[14];
                              pData[2] = pData[15];
              
                              ((UINT32*)pData)[3] = (((UINT32*)pData)[3] - (UINT32) 1048576 * FlatSdFac / 64) / (w1 - 1);
              
                              if (((UINT32*)pData)[3] > 0x3fff) //Accumulated factor too large
                                      return;
                              
                              pData[3] = pData[14] & 0x3f;
                              pData[4] = pData[15];
              
              
                              CTimerWaitForEvent(_EVENT_IEN_STOP);
              
                              CScalerSetByte(_SD_ACCESS_PORT_24, 0x85);
                              CScalerSetByte(_SD_ACCESS_PORT_24, 0x85);
                              CScalerWrite(_SD_DATA_PORT_25, 5, pData, _NON_AUTOINC); //hill modified for scale down error
                              CScalerSetByte(_SD_ACCESS_PORT_24, 0x00);
              
                              //Data[0] = 4;
                              //Data[1] = info->channel ? _P1_4C_SD_ACC_WIDTHH : _P1_2C_SD_ACC_WIDTHH;
                              pData[0] = HIBYTE(w1);
                              pData[1] = LOBYTE(w1);
                              pData[2] = HIBYTE(w2);
                              pData[3] = LOBYTE(w2);
                              //Data[6] = 0;
                              //CRtdWrite();
                              CScalerSetByte(_SD_ACCESS_PORT_24, 0x8a);
                              CScalerSetByte(_SD_ACCESS_PORT_24, 0x8a);
                              CScalerWrite(_SD_DATA_PORT_25, 4, pData, _NON_AUTOINC); //hill modified for scale down error
                              CScalerSetByte(_SD_ACCESS_PORT_24, 0x00);
              
                              CScalerSetBit(_SCALE_DOWN_CTRL_23, 0xff, 0x08);
                              CTimerDelayXms(120);
                              CScalerSetByte(_STATUS0_02, 0x00);
                              //CRtdClearBits((info->channel ? _P1_41_SD_CTRL2 : _P1_21_SD_CTRL2), _BIT2); // enable non-linear scalin
             -g down
                      } // end of (GET_NONLINEAR_ON() && GET_HSCALE_UP()) // non-linear scaling
              
              }
              #endif
 539          //731301***
 540          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))//V402 modify
 541          //--------------------------------------------------
C51 COMPILER V9.00   SCALER                                                                08/25/2023 16:47:33 PAGE 10  

 542          // Description  : Switch the Digital Input Port
 543          // Input Value  : usSwitch  --> Parameter for Digital Input Port
 544          // Output Value : None
 545          //--------------------------------------------------
 546          #if 0
              void CScalerDigitalPortSwitch(void)
              {
                      CScalerPageSelect(_PAGE2);
              
                      if(!CHdmiFormatDetect())
                      {
                          CScalerSetBit(_P2_POWER_ON_OFF_CTRL_A7, ~(_BIT6 | _BIT5), 0x00);
                      }
                      else
                      {
                          CScalerSetBit(_P2_POWER_ON_OFF_CTRL_A7, ~(_BIT6 | _BIT5), (_BIT6 | _BIT5));
                      }
              
                 /* switch(usSwitch)
                  {
                      case _DVI_D0_PORT:
                      case _HDMI_H0_PORT:
                          CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~_BIT1, 0x00);
                          CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT1 | _BIT0), _BIT1 | _BIT0);
                          CScalerSetBit(_P2_HDCP_PORT_CTRL_C2, ~_BIT1, 0x00);
                          break;
              
                      case _DVI_D1_PORT:
                      case _HDMI_H1_PORT:
                          CScalerSetBit(_P2_TMDS_MEAS_RESULT0_A2, ~_BIT1, _BIT1);
                          CScalerSetBit(_P2_ANALOG_COMMON_CTRL2_AB, ~(_BIT1 | _BIT0), _BIT1 | _BIT0);
                          CScalerSetBit(_P2_HDCP_PORT_CTRL_C2, ~_BIT1, _BIT1);
                          break;
                  }*/
                  CTimerDelayXms(200);
                  CScalerSetBit(_P2_HDCP_CTRL_C0, ~_BIT0, _BIT0);
              }
              #endif
 580          #endif
 581          //731301###


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    639    ----
   CONSTANT SIZE    =   1129    ----
   XDATA SIZE       =      2       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
